<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ANY EVER | Podcast Generator</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LameJS for MP3 Encoding (Global Script) -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Babel Standalone for In-Browser Compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      :root {
        --any-ever-white: #ffffff;
        --any-ever-black: #181818;
        --any-ever-gold: #c0ae66;
        --any-ever-dark-grey: #333333;
        --any-ever-stone-grey: #e5e5e5;
        --any-ever-light-grey: #717684;
        --any-ever-bright-grey: #f9f9f9;
        --border-light: rgba(0,0,0,0.05);
        --font-weight-medium: 500;
        --font-weight-bold: 700;
        --letter-spacing-medium: 0.05em;
        --letter-spacing-normal: 0.01em;
        --shadow-gold: 0 8px 18px rgba(192,174,102,0.24);
        --gradient-gold: linear-gradient(135deg, #d4c585 0%, #c0ae66 100%);
      }

      body {
        font-family: 'Inter', sans-serif;
        background-color: var(--any-ever-bright-grey);
        color: var(--any-ever-black);
        margin: 0;
        padding: 24px;
      }

      /* Custom Scrollbar */
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

      h1, h2, h3, h4 { font-weight: var(--font-weight-medium); letter-spacing: var(--letter-spacing-normal); }

      .btn-primary {
        background: var(--gradient-gold);
        color: white;
        box-shadow: var(--shadow-gold);
        transition: all 0.2s ease;
      }
      .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(192,174,102,0.3); }
      .btn-primary:disabled { background: var(--any-ever-stone-grey); box-shadow: none; transform: none; cursor: not-allowed; }

      .card {
        background: var(--any-ever-white);
        border: 1px solid rgba(0,0,0,0.05);
        border-radius: 16px;
        box-shadow: 0 4px 18px rgba(0,0,0,0.04);
      }
      
      .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      
      #error-log {
        display: none;
        position: fixed; top: 0; left: 0; width: 100%; background: #fee2e2; color: #991b1b; padding: 20px; z-index: 9999; border-bottom: 1px solid #ef4444; font-family: monospace; white-space: pre-wrap; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }
    </style>

    <!-- Import Map for reliable external dependencies -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.344.0",
    "@google/genai": "https://esm.sh/@google/genai@0.1.1",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
  </head>
  <body>
    <div id="error-log"></div>
    <div id="root"></div>
    
    <script>
        // GLOBAL ERROR HANDLER
        window.onerror = function(msg, url, line, col, error) {
            const div = document.getElementById('error-log');
            if(div) {
                div.style.display = 'block';
                div.innerText = `APP CRASH:\n${msg}\nLine: ${line}\nCheck console for details.`;
            }
            console.error("Global Error:", error);
        };
        
        // POLYFILLS for GenAI SDK
        window.process = { env: { API_KEY: '' } }; 
        window.Buffer = {
            from: (str, encoding) => {
                if (encoding === 'base64') {
                    const bin = atob(str);
                    const arr = new Uint8Array(bin.length);
                    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
                    return arr;
                }
                return new TextEncoder().encode(str);
            }
        };
    </script>

    <!-- MAIN APPLICATION CODE -->
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { 
        Sparkles, Users, Globe, Settings, ChevronUp, ChevronDown, RotateCcw, 
        Rss, Plus, Trash2, ExternalLink, Mic, Play, Volume2, Disc, 
        Music, Upload, Save, CheckCircle2, Mail, Download, FileAudio, X, Send, Loader2, Square 
      } from 'lucide-react';
      import { GoogleGenAI, Modality, HarmCategory, HarmBlockThreshold } from "@google/genai";

      // ==========================================
      // 1. CONFIG & TYPES
      // ==========================================

      const N8N_WEBHOOK_URL = 'https://anymal.app.n8n.cloud/webhook/send_mail';
      const API_KEY = process.env.API_KEY || ''; 

      // ENUMS & INTERFACES
      const VoiceName = {
        Puck: 'Puck',
        Charon: 'Charon',
        Kore: 'Kore',
        Fenrir: 'Fenrir',
        Zephyr: 'Zephyr',
      };

      // ==========================================
      // 2. UTILS
      // ==========================================

      // --- Audio Utils ---
      const decodeBase64Audio = async (base64String, ctx) => {
        const binaryString = atob(base64String);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
        
        let bufferToUse = bytes.buffer;
        if (bytes.byteLength % 2 !== 0) bufferToUse = bytes.buffer.slice(0, bytes.byteLength - 1);
        
        const dataInt16 = new Int16Array(bufferToUse);
        const numChannels = 1;
        const sampleRate = 24000; 
        const frameCount = dataInt16.length / numChannels;
        
        const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);
        const channelData = buffer.getChannelData(0);
        
        for (let i = 0; i < frameCount; i++) channelData[i] = dataInt16[i] / 32768.0;
        return buffer;
      };

      const decodeAudioBlob = async (blob, ctx) => {
        const arrayBuffer = await blob.arrayBuffer();
        return await ctx.decodeAudioData(arrayBuffer);
      };

      const mixPodcastSequence = async (voiceBuffer, backgroundBuffer, introBuffer, outroBuffer, musicVolume, introVolume, outroVolume) => {
        const outputSampleRate = 44100; 
        const numberOfChannels = 2; 
        const introDur = introBuffer ? introBuffer.duration : 0;
        const voiceDur = voiceBuffer.duration;
        const outroDur = outroBuffer ? outroBuffer.duration : 0;
        const totalDuration = introDur + voiceDur + outroDur;
        const safeDuration = Math.max(totalDuration, 0.001);
        const length = Math.ceil(safeDuration * outputSampleRate);
        const offlineCtx = new OfflineAudioContext(numberOfChannels, length, outputSampleRate);

        const createSource = (buffer, vol, startTime, stopTime, loop = false) => {
          const safeVol = isFinite(vol) && vol >= 0 ? vol : 0;
          const source = offlineCtx.createBufferSource();
          source.buffer = buffer;
          source.loop = loop;
          const gainNode = offlineCtx.createGain();
          gainNode.gain.value = safeVol;
          source.connect(gainNode);
          gainNode.connect(offlineCtx.destination);
          source.start(startTime);
          if (stopTime !== undefined && stopTime > startTime) source.stop(stopTime);
          return source;
        };

        if (introBuffer) createSource(introBuffer, introVolume, 0);
        createSource(voiceBuffer, 1.0, introDur);
        if (backgroundBuffer) createSource(backgroundBuffer, musicVolume, introDur, introDur + voiceDur, true);
        if (outroBuffer) createSource(outroBuffer, outroVolume, introDur + voiceDur);

        return await offlineCtx.startRendering();
      };

      const audioBufferToMp3 = (buffer) => {
        const lamejs = window.lamejs;
        if (!lamejs) throw new Error("Lamejs library not found. Check internet connection.");
        const channels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        const kbps = 320; 
        const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, kbps);
        const mp3Data = [];
        const rawLeft = buffer.getChannelData(0);
        const rawRight = channels > 1 ? buffer.getChannelData(1) : rawLeft;
        const length = rawLeft.length;
        const sampleBlockSize = 1152; 
        const leftInt16 = new Int16Array(sampleBlockSize);
        const rightInt16 = new Int16Array(sampleBlockSize);
        
        for (let i = 0; i < length; i += sampleBlockSize) {
          const chunkLen = Math.min(sampleBlockSize, length - i);
          for (let j = 0; j < chunkLen; j++) {
            const l = Math.max(-1, Math.min(1, rawLeft[i + j]));
            const r = Math.max(-1, Math.min(1, rawRight[i + j]));
            leftInt16[j] = (l < 0 ? l * 32768 : l * 32767);
            rightInt16[j] = (r < 0 ? r * 32768 : r * 32767);
          }
          const leftChunk = (chunkLen === sampleBlockSize) ? leftInt16 : leftInt16.subarray(0, chunkLen);
          const rightChunk = (chunkLen === sampleBlockSize) ? rightInt16 : rightInt16.subarray(0, chunkLen);
          const mp3buf = (channels === 1) ? mp3encoder.encodeBuffer(leftChunk) : mp3encoder.encodeBuffer(leftChunk, rightChunk);
          if (mp3buf.length > 0) mp3Data.push(mp3buf);
        }
        const mp3buf = mp3encoder.flush();
        if (mp3buf.length > 0) mp3Data.push(mp3buf);
        return new Blob(mp3Data, { type: 'audio/mp3' });
      };

      const audioBufferToWav = (buffer) => {
        const numOfChan = buffer.numberOfChannels;
        const length = buffer.length * numOfChan * 2 + 44;
        const bufferArr = new ArrayBuffer(length);
        const view = new DataView(bufferArr);
        const channels = [];
        let i, sample, offset = 0, pos = 0;
        const setUint16 = (data) => { view.setUint16(pos, data, true); pos += 2; };
        const setUint32 = (data) => { view.setUint32(pos, data, true); pos += 4; };

        setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157); 
        setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
        setUint32(buffer.sampleRate); setUint32(buffer.sampleRate * 2 * numOfChan); 
        setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4); 

        for (i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));

        while (pos < buffer.length) {
          for (i = 0; i < numOfChan; i++) {
            sample = Math.max(-1, Math.min(1, channels[i][pos])); 
            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; 
            view.setInt16(44 + offset, sample, true); 
            offset += 2;
          }
          pos++;
        }
        return new Blob([bufferArr], { type: "audio/wav" });
      };

      const blobToBase64 = (blob) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            if (typeof reader.result === 'string') {
              const base64 = reader.result.split(',')[1];
              resolve(base64);
            } else reject(new Error('Failed to convert blob to base64'));
          };
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      };

      // --- DB Utils ---
      const DB_NAME = 'GeminiPodcastStudioDB';
      const STORE_NAME = 'audioFiles';
      const openDB = () => {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, 1);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
          };
        });
      };
      const storeAudioFile = async (key, file) => {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORE_NAME);
          store.put({ name: file.name, blob: file }, key);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      };
      const getAudioFile = async (key) => {
        try {
          const db = await openDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const store = tx.objectStore(STORE_NAME);
            const req = store.get(key);
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => reject(req.error);
          });
        } catch (err) { return null; }
      };
      const deleteAudioFile = async (key) => {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORE_NAME);
          store.delete(key);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      };

      // --- RSS Utils ---
      const fetchFeedContent = async (url) => {
        const cleanUrl = url.trim();
        const encodedUrl = encodeURIComponent(cleanUrl);
        try {
          const response = await fetch(`https://api.allorigins.win/get?url=${encodedUrl}`);
          if (response.ok) {
            const data = await response.json();
            if (data.contents) return data.contents;
          }
        } catch (e) { console.warn(`AllOrigins failed`, e); }
        try {
          const response = await fetch(`https://corsproxy.io/?${encodedUrl}`);
          if (response.ok) return await response.text();
        } catch (e) { console.warn(`CorsProxy failed`, e); }
        return null;
      };

      const fetchRssFeeds = async (urls) => {
        if (urls.length === 0) return { combinedContent: "", articles: [] };
        let combinedContent = "RSS FEED QUELLEMATERIAL (STRICT USE ONLY):\n";
        const allArticles = [];
        const validUrls = urls.filter(u => u.trim().length > 0);

        for (const url of validUrls) {
          try {
            const xmlString = await fetchFeedContent(url);
            if (!xmlString) {
              combinedContent += `\n(Fehler beim Laden: ${url})\n`;
              continue;
            }
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "text/xml");
            if (xmlDoc.querySelector("parsererror")) continue;

            let channelTitle = "Unbekannt";
            const titleNode = xmlDoc.querySelector("channel > title") || xmlDoc.querySelector("feed > title");
            if (titleNode) channelTitle = titleNode.textContent.trim();

            const items = Array.from(xmlDoc.querySelectorAll("item, entry")).slice(0, 5);
            combinedContent += `\n=== QUELLE: ${channelTitle} ===\n`;

            items.forEach(item => {
              const title = item.querySelector("title")?.textContent?.trim() || "Ohne Titel";
              const contentEncoded = item.getElementsByTagName("content:encoded")[0]?.textContent;
              const description = item.querySelector("description")?.textContent;
              const summary = item.querySelector("summary")?.textContent;
              const content = item.querySelector("content")?.textContent;
              
              let fullText = contentEncoded || content || description || summary || "";
              fullText = fullText.replace(/<[^>]*>?/gm, ' ').replace(/\s+/g, ' ').trim();
              
              let link = "";
              const atomLinks = item.getElementsByTagName("link");
              if (atomLinks.length > 0) {
                  for (let i = 0; i < atomLinks.length; i++) {
                      const href = atomLinks[i].getAttribute("href");
                      if (href) { link = href; break; }
                      if (atomLinks[i].textContent && atomLinks[i].textContent.startsWith('http')) {
                          link = atomLinks[i].textContent.trim();
                          break;
                      }
                  }
              }
              if (!link) {
                   const directLink = item.querySelector("link")?.textContent?.trim();
                   if (directLink && directLink.startsWith('http')) link = directLink;
              }
              if (!link) {
                  const idNode = item.querySelector("guid, id");
                  const idText = idNode?.textContent?.trim();
                  if (idText && (idText.startsWith("http") || idText.startsWith("https"))) link = idText;
              }

              allArticles.push({ title, description: fullText.substring(0, 300), link: link || "N/A", source: channelTitle });
              
              combinedContent += `\n- ARTIKEL: "${title}"\n  QUELLE: ${channelTitle}\n  LINK: ${link}\n`; 
              if (fullText) combinedContent += `  INHALT: ${fullText.length > 2500 ? fullText.substring(0, 2500) + "..." : fullText}\n`;
            });
          } catch (e) { console.error(`RSS Error ${url}`, e); }
        }
        return { combinedContent, articles: allArticles };
      };

      // ==========================================
      // 3. GEMINI SERVICE
      // ==========================================
      const ai = new GoogleGenAI({ apiKey: API_KEY });

      const generateScript = async (topic, hostName, guestName, useSearch, rssContent, customInstruction) => {
        const modelId = "gemini-2.5-flash";
        const defaultInst = `Du bist ein professioneller Podcast-Produzent. Schreibe einen tiefgründigen Dialog auf DEUTSCH.`;
        const systemInstruction = customInstruction || defaultInst;

        let userPrompt = `Thema: "${topic}"\nSprecher 1: "${hostName}"\nSprecher 2: "${guestName}"\n`;

        if (rssContent) {
          userPrompt += `\nRSS-MODUS AKTIV. NUTZE NUR DIESE QUELLEN:\n${rssContent}\n`;
          userPrompt += `REGELN:\n1. Deduplizieren.\n2. Relevanz prüfen (Top 3-4 Themen).\n3. ZITIERPFLICHT: Nenne Quellen verbal.\n`;
        }
        userPrompt += `\nGeneriere das Skript auf DEUTSCH.`;

        const config = { temperature: 0.3, systemInstruction: systemInstruction };
        if (useSearch) config.tools = [{ googleSearch: {} }];

        const response = await ai.models.generateContent({ model: modelId, contents: userPrompt, config: config });
        
        const text = response.text || "";
        let searchSources = [];
        const chunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
        if (chunks) {
          chunks.forEach(chunk => {
             if (chunk.web) searchSources.push({ title: chunk.web.title, uri: chunk.web.uri });
          });
        }
        
        return {
          title: `AI-Podcast: ${topic} - ${new Date().toLocaleDateString('de-DE')}`,
          script: text,
          searchSources
        };
      };

      const generateVoicePreview = async (voice, text) => {
        const response = await ai.models.generateContent({
          model: "gemini-2.5-flash-preview-tts",
          contents: [{ parts: [{ text: text }] }],
          config: {
            responseModalities: [Modality.AUDIO],
            speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voice } } }
          }
        });
        const parts = response.candidates?.[0]?.content?.parts;
        if (!parts?.[0]?.inlineData?.data) throw new Error("No audio content.");
        return parts[0].inlineData.data;
      };

      const generatePodcastAudio = async (script, hostName, guestName, hostVoice, guestVoice) => {
        const cleaned = script.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1');
        const response = await ai.models.generateContent({
          model: "gemini-2.5-flash-preview-tts",
          contents: [{ parts: [{ text: cleaned }] }],
          config: {
            responseModalities: [Modality.AUDIO],
            speechConfig: {
              multiSpeakerVoiceConfig: {
                speakerVoiceConfigs: [
                  { speaker: hostName, voiceConfig: { prebuiltVoiceConfig: { voiceName: hostVoice } } },
                  { speaker: guestName, voiceConfig: { prebuiltVoiceConfig: { voiceName: guestVoice } } }
                ]
              }
            },
            safetySettings: [
              { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
              { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
              { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
              { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH }
            ]
          }
        });
        const parts = response.candidates?.[0]?.content?.parts;
        if (!parts?.[0]?.inlineData?.data) throw new Error("No audio data.");
        return parts[0].inlineData.data;
      };

      // ==========================================
      // 4. COMPONENTS
      // ==========================================

      const ScriptSection = ({ onScriptReady, hostName, setHostName, guestName, setGuestName, topic, setTopic, setRssArticles, setSearchSources }) => {
        const [loading, setLoading] = useState(false);
        const [status, setStatus] = useState("");
        const [useSearch, setUseSearch] = useState(() => localStorage.getItem('useSearch') === 'true');
        const [useRss, setUseRss] = useState(() => localStorage.getItem('useRss') === 'true');
        const [showRssInput, setShowRssInput] = useState(false);
        const [rssFeeds, setRssFeeds] = useState(() => {
            try { return JSON.parse(localStorage.getItem('rssFeedsList') || '[]'); } catch { return []; }
        });
        const [newRss, setNewRss] = useState('');
        const [script, setScript] = useState('');
        const [sources, setSources] = useState([]);
        const [localRss, setLocalRss] = useState([]);
        const [showSettings, setShowSettings] = useState(false);
        const [sysInst, setSysInst] = useState(() => localStorage.getItem('sysInst') || "");

        useEffect(() => localStorage.setItem('useSearch', useSearch), [useSearch]);
        useEffect(() => { localStorage.setItem('useRss', useRss); if(useRss) setShowRssInput(true); }, [useRss]);
        useEffect(() => localStorage.setItem('rssFeedsList', JSON.stringify(rssFeeds)), [rssFeeds]);
        useEffect(() => localStorage.setItem('sysInst', sysInst), [sysInst]);

        const addFeed = () => { if(newRss && !rssFeeds.includes(newRss)) setRssFeeds([...rssFeeds, newRss]); setNewRss(''); };
        const removeFeed = (i) => { const n = [...rssFeeds]; n.splice(i, 1); setRssFeeds(n); };

        const handleGenerate = async () => {
          if(!topic || !hostName || !guestName) return;
          setLoading(true); setSources([]); setSearchSources([]); setLocalRss([]); setRssArticles([]);
          try {
             let rssContent = "";
             if(useRss && rssFeeds.length) {
                 setStatus("Lese Feeds...");
                 const res = await fetchRssFeeds(rssFeeds);
                 rssContent = res.combinedContent;
                 setRssArticles(res.articles);
                 setLocalRss(res.articles);
             }
             setStatus("Schreibe Skript...");
             const res = await generateScript(topic, hostName, guestName, useSearch, rssContent, sysInst);
             setScript(res.script);
             if(res.searchSources) { setSources(res.searchSources); setSearchSources(res.searchSources); }
             onScriptReady(res.script);
          } catch(e) { alert("Fehler: " + e.message); }
          finally { setLoading(false); }
        };

        return (
          <div className="card p-8">
             <div className="border-b border-[#c0ae66] pb-4 mb-6">
               <h2 className="text-xl font-medium flex items-center gap-2"><Sparkles className="text-[#c0ae66]"/> SCHRITT 1: SKRIPT</h2>
             </div>
             <div className="space-y-6">
                <div className="grid grid-cols-2 gap-6">
                    <div><label className="text-xs font-bold uppercase mb-2 block">Host</label><input className="w-full rounded-xl p-3 border" value={hostName} onChange={e=>setHostName(e.target.value)}/></div>
                    <div><label className="text-xs font-bold uppercase mb-2 block">Gast</label><input className="w-full rounded-xl p-3 border" value={guestName} onChange={e=>setGuestName(e.target.value)}/></div>
                </div>
                <div><label className="text-xs font-bold uppercase mb-2 block">Thema</label><input className="w-full rounded-xl p-3 border" value={topic} onChange={e=>setTopic(e.target.value)}/></div>
                
                <div className="grid grid-cols-2 gap-4">
                    <label className="flex gap-2 p-4 bg-[#f9f9f9] border rounded-xl items-center"><input type="checkbox" checked={useSearch} onChange={e=>setUseSearch(e.target.checked)}/> Google Search</label>
                    <label className="flex gap-2 p-4 bg-[#f9f9f9] border rounded-xl items-center"><input type="checkbox" checked={useRss} onChange={e=>setUseRss(e.target.checked)}/> RSS Feeds</label>
                </div>
                
                {useRss && (
                    <div className="bg-white border rounded-xl p-4">
                        <div className="flex gap-2 mb-2"><input className="flex-1 rounded-full px-4 border" value={newRss} onChange={e=>setNewRss(e.target.value)} placeholder="Feed URL"/><button onClick={addFeed} className="btn-primary w-10 h-10 rounded-full flex justify-center items-center"><Plus/></button></div>
                        <ul>{rssFeeds.map((u,i)=><li key={i} className="flex justify-between text-sm p-2 bg-gray-50 rounded mb-1">{u}<button onClick={()=>removeFeed(i)}><Trash2 className="w-4 h-4 text-red-500"/></button></li>)}</ul>
                    </div>
                )}

                <button onClick={()=>setShowSettings(!showSettings)} className="text-xs text-gray-500 flex items-center gap-1"><Settings className="w-3 h-3"/> Einstellungen</button>
                {showSettings && <textarea className="w-full p-3 border rounded-xl text-xs font-mono" rows={4} value={sysInst} onChange={e=>setSysInst(e.target.value)} placeholder="System Prompt..."/>}
                
                <button onClick={handleGenerate} disabled={loading} className="btn-primary w-full py-4 rounded-full font-bold uppercase flex justify-center items-center gap-2">{loading?<Loader2 className="animate-spin"/>:<Sparkles/>} Generieren</button>
                
                {script && (
                    <div className="mt-8 border-t pt-8">
                        <textarea className="w-full p-6 border rounded-xl font-mono text-sm shadow-inner" rows={12} value={script} onChange={e=>{setScript(e.target.value); onScriptReady(e.target.value);}}/>
                        {localRss.length > 0 && <div className="mt-4 bg-gray-50 p-4 rounded-xl text-sm"><h4 className="font-bold mb-2">RSS Quellen:</h4><ul>{localRss.map((a,i)=><li key={i}><a href={a.link} target="_blank" className="text-[#c0ae66] hover:underline">{a.title} ({a.source})</a></li>)}</ul></div>}
                        {sources.length > 0 && <div className="mt-4 bg-gray-50 p-4 rounded-xl text-sm"><h4 className="font-bold mb-2">Google Quellen:</h4><ul>{sources.map((s,i)=><li key={i}><a href={s.uri} target="_blank" className="text-[#c0ae66] hover:underline">{s.title}</a></li>)}</ul></div>}
                    </div>
                )}
             </div>
          </div>
        );
      };

      const AudioSection = ({ script, hostName, guestName, topic, rssArticles, searchSources }) => {
        const [hostVoice, setHostVoice] = useState(() => localStorage.getItem('hostVoice') || VoiceName.Kore);
        const [guestVoice, setGuestVoice] = useState(() => localStorage.getItem('guestVoice') || VoiceName.Puck);
        
        const [introFile, setIntroFile] = useState(null);
        const [outroFile, setOutroFile] = useState(null);
        const [musicSlots, setMusicSlots] = useState([null, null, null]);
        
        const [selMusicIdx, setSelMusicIdx] = useState(() => parseInt(localStorage.getItem('selMusicIdx') || '-1'));
        const [musVol, setMusVol] = useState(() => parseFloat(localStorage.getItem('musVol') || '0.1'));
        const [intVol, setIntVol] = useState(() => parseFloat(localStorage.getItem('intVol') || '0.5'));
        const [outVol, setOutVol] = useState(() => parseFloat(localStorage.getItem('outVol') || '0.5'));
        
        const [loading, setLoading] = useState(false);
        const [audioUrl, setAudioUrl] = useState(null);
        const [audioBlob, setAudioBlob] = useState(null);
        const [prevPlaying, setPrevPlaying] = useState(null);
        const prevRef = useRef(null);

        const [showMail, setShowMail] = useState(false);
        const [mailTo, setMailTo] = useState("");
        const [mailSubj, setMailSubj] = useState("");
        const [mailBody, setMailBody] = useState("");
        const [sending, setSending] = useState(false);
        const [sent, setSent] = useState(false);

        useEffect(() => {
           getAudioFile('intro').then(setIntroFile);
           getAudioFile('outro').then(setOutroFile);
           Promise.all([getAudioFile('m0'), getAudioFile('m1'), getAudioFile('m2')]).then(setMusicSlots);
        }, []);

        useEffect(() => { localStorage.setItem('hostVoice', hostVoice); }, [hostVoice]);
        useEffect(() => { localStorage.setItem('guestVoice', guestVoice); }, [guestVoice]);
        useEffect(() => { localStorage.setItem('selMusicIdx', selMusicIdx); }, [selMusicIdx]);
        useEffect(() => { localStorage.setItem('musVol', musVol); localStorage.setItem('intVol', intVol); localStorage.setItem('outVol', outVol); }, [musVol, intVol, outVol]);

        const handleSave = () => alert("Einstellungen gespeichert!");

        const handleFile = async (e, type, idx) => {
           const f = e.target.files[0];
           if(!f) return;
           if(type === 'intro') { await storeAudioFile('intro', f); setIntroFile({name:f.name, blob:f}); }
           else if(type === 'outro') { await storeAudioFile('outro', f); setOutroFile({name:f.name, blob:f}); }
           else { await storeAudioFile(`m${idx}`, f); const s=[...musicSlots]; s[idx]={name:f.name, blob:f}; setMusicSlots(s); setSelMusicIdx(idx); }
        };
        
        const handleDelete = async (type, idx) => {
           if(type === 'intro') { await deleteAudioFile('intro'); setIntroFile(null); }
           else if(type === 'outro') { await deleteAudioFile('outro'); setOutroFile(null); }
           else { await deleteAudioFile(`m${idx}`); const s=[...musicSlots]; s[idx]=null; setMusicSlots(s); if(selMusicIdx===idx) setSelMusicIdx(-1); }
        };

        const playPreview = (blob, id) => {
           if(prevRef.current) { prevRef.current.pause(); prevRef.current = null; }
           if(prevPlaying === id) { setPrevPlaying(null); return; }
           const url = URL.createObjectURL(blob);
           const a = new Audio(url);
           a.onended = () => { setPrevPlaying(null); URL.revokeObjectURL(url); };
           prevRef.current = a;
           a.play();
           setPrevPlaying(id);
        };

        const previewVoice = async (voice, id) => {
           try {
             const b64 = await generateVoicePreview(voice, `Hallo, ich bin ${voice}.`);
             const ctx = new AudioContext();
             const buf = await decodeBase64Audio(b64, ctx);
             const blob = audioBufferToWav(buf);
             playPreview(blob, id);
             ctx.close();
           } catch(e) { console.error(e); }
        };

        const generate = async () => {
           if(!script) return;
           setLoading(true); setAudioUrl(null);
           try {
              const ctx = new AudioContext();
              const vB64 = await generatePodcastAudio(script, hostName, guestName, hostVoice, guestVoice);
              const vBuf = await decodeBase64Audio(vB64, ctx);
              let mBuf=null, iBuf=null, oBuf=null;
              if(selMusicIdx !== -1 && musicSlots[selMusicIdx]) mBuf = await decodeAudioBlob(musicSlots[selMusicIdx].blob, ctx);
              if(introFile) iBuf = await decodeAudioBlob(introFile.blob, ctx);
              if(outroFile) oBuf = await decodeAudioBlob(outroFile.blob, ctx);
              
              const mix = await mixPodcastSequence(vBuf, mBuf, iBuf, oBuf, musVol, intVol, outVol);
              const mp3 = audioBufferToMp3(mix);
              setAudioBlob(mp3);
              setAudioUrl(URL.createObjectURL(mp3));
              ctx.close();
           } catch(e) { alert("Audio Error: " + e.message); }
           finally { setLoading(false); }
        };

        const openMail = () => {
           const d = new Date().toLocaleDateString();
           setMailSubj(`Podcast: ${topic.substring(0,20)}... - ${d}`);
           let src = "";
           if(rssArticles?.length) { src += "\n\nRSS:\n" + rssArticles.map(a=>`• ${a.title} (${a.link})`).join("\n"); }
           if(searchSources?.length) { src += "\n\nWEB:\n" + searchSources.map(s=>`• ${s.title} (${s.uri})`).join("\n"); }
           setMailBody(`Hier ist dein Podcast!\n\n${src}`);
           setShowMail(true);
        };

        const sendMail = async () => {
           if(!mailTo || !audioBlob) return;
           setSending(true);
           try {
              const b64 = await blobToBase64(audioBlob);
              const payload = { to: mailTo, subject: mailSubj, body: mailBody, attachmentName: "podcast.mp3", attachmentBase64: b64 };
              let res;
              try { res = await fetch(N8N_WEBHOOK_URL, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload)}); }
              catch { res = await fetch(`https://corsproxy.io/?${encodeURIComponent(N8N_WEBHOOK_URL)}`, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload)}); }
              
              if(!res.ok) throw new Error("Send failed");
              setSent(true); setTimeout(()=>setShowMail(false), 2000);
           } catch(e) { alert("Mail Error: " + e.message); }
           finally { setSending(false); }
        };

        return (
          <div className={`card p-8 ${!script ? 'opacity-50 pointer-events-none' : ''}`}>
             <div className="border-b border-[#c0ae66] pb-4 mb-6 flex justify-between">
                <h2 className="text-xl font-medium flex items-center gap-2"><Volume2 className="text-[#c0ae66]"/> SCHRITT 2: AUDIO</h2>
                <button onClick={handleSave} className="text-xs bg-gray-100 px-3 py-1 rounded-full">Speichern</button>
             </div>
             
             <div className="space-y-6">
                <div className="grid grid-cols-2 gap-6">
                   {[hostVoice, guestVoice].map((v, i) => (
                      <div key={i} className="bg-gray-50 p-4 rounded-xl">
                         <label className="text-xs font-bold block mb-2">{i===0?hostName:guestName}</label>
                         <div className="flex gap-2">
                            <select className="flex-1 rounded-lg border p-2" value={v} onChange={e=>i===0?setHostVoice(e.target.value):setGuestVoice(e.target.value)}>{Object.values(VoiceName).map(x=><option key={x} value={x}>{x}</option>)}</select>
                            <button onClick={()=>previewVoice(v, i===0?'h':'g')} className="bg-white p-2 border rounded-lg"><Play className="w-4 h-4"/></button>
                         </div>
                      </div>
                   ))}
                </div>

                <div className="grid grid-cols-2 gap-6">
                   {['intro', 'outro'].map(t => {
                      const f = t==='intro'?introFile:outroFile;
                      const vol = t==='intro'?intVol:outVol;
                      const setV = t==='intro'?setIntVol:setOutVol;
                      return (
                         <div key={t} className="border p-4 rounded-xl">
                            <div className="flex justify-between mb-2"><span className="capitalize font-bold">{t}</span> {f && <button onClick={()=>handleDelete(t)}><Trash2 className="w-4 h-4 text-red-500"/></button>}</div>
                            <label className="block w-full bg-gray-50 border p-2 rounded mb-2 text-xs truncate">{f?f.name:"Upload..."}<input type="file" className="hidden" onChange={e=>handleFile(e,t)}/></label>
                            <input type="range" min="0" max="1" step="0.1" value={vol} onChange={e=>setV(parseFloat(e.target.value))} className="w-full accent-[#c0ae66]"/>
                         </div>
                      );
                   })}
                </div>

                <div>
                   <h3 className="text-xs font-bold mb-2">Hintergrund Musik ({Math.round(musVol*100)}%)</h3>
                   <input type="range" min="0" max="0.5" step="0.05" value={musVol} onChange={e=>setMusVol(parseFloat(e.target.value))} className="w-full mb-4 accent-[#c0ae66]"/>
                   <div className="grid grid-cols-4 gap-2">
                      <button onClick={()=>setSelMusicIdx(-1)} className={`border p-2 rounded-xl h-24 ${selMusicIdx===-1?'border-[#c0ae66] bg-yellow-50':''}`}>Keine</button>
                      {[0,1,2].map(i => (
                         <div key={i} onClick={()=>musicSlots[i] && setSelMusicIdx(i)} className={`border p-2 rounded-xl h-24 relative ${selMusicIdx===i?'border-[#c0ae66] bg-yellow-50':''}`}>
                            {!musicSlots[i] ? <label className="flex flex-col items-center justify-center h-full text-xs text-gray-400 cursor-pointer"><Upload className="w-4 h-4 mb-1"/>Upload<input type="file" className="hidden" onChange={e=>handleFile(e,'m',i)}/></label> 
                            : <><div className="text-xs truncate">{musicSlots[i].name}</div><button onClick={(e)=>{e.stopPropagation(); handleDelete('m',i)}} className="absolute bottom-2 right-2 text-red-400"><Trash2 className="w-4 h-4"/></button></>}
                         </div>
                      ))}
                   </div>
                </div>

                <button onClick={generate} disabled={loading} className="btn-primary w-full py-4 rounded-full font-bold uppercase flex justify-center items-center gap-2">{loading?<Loader2 className="animate-spin"/>:<Music/>} Podcast Erstellen</button>
                
                {audioUrl && (
                   <div className="bg-white border border-[#c0ae66] p-6 rounded-2xl shadow-lg mt-4">
                      <div className="flex justify-between items-center mb-4">
                         <h3 className="font-bold">Fertiger Podcast</h3>
                         <div className="flex gap-2">
                            <button onClick={openMail} className="bg-gray-100 px-4 py-2 rounded-full text-sm flex gap-2"><Mail className="w-4 h-4"/> Email</button>
                            <a href={audioUrl} download="podcast.mp3" className="bg-black text-white px-4 py-2 rounded-full text-sm flex gap-2"><Download className="w-4 h-4"/> DL</a>
                         </div>
                      </div>
                      <audio src={audioUrl} controls className="w-full"/>
                   </div>
                )}
             </div>

             {showMail && (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                   <div className="bg-white p-6 rounded-2xl w-full max-w-lg shadow-2xl">
                      <h3 className="font-bold mb-4">Senden</h3>
                      <input className="w-full border p-2 rounded mb-2" placeholder="Email" value={mailTo} onChange={e=>setMailTo(e.target.value)}/>
                      <input className="w-full border p-2 rounded mb-2" placeholder="Betreff" value={mailSubj} onChange={e=>setMailSubj(e.target.value)}/>
                      <textarea className="w-full border p-2 rounded mb-4 text-xs font-mono" rows={5} value={mailBody} onChange={e=>setMailBody(e.target.value)}/>
                      <div className="flex justify-end gap-2">
                         <button onClick={()=>setShowMail(false)} className="px-4 py-2 text-gray-500">Abbrechen</button>
                         <button onClick={sendMail} disabled={sending} className="btn-primary px-6 py-2 rounded-full text-sm">{sending?'Senden...':(sent?'Gesendet!':'Abschicken')}</button>
                      </div>
                   </div>
                </div>
             )}
          </div>
        );
      };

      // ==========================================
      // 5. APP ROOT
      // ==========================================
      const App = () => {
         const [script, setScript] = useState(() => localStorage.getItem('script') || '');
         const [topic, setTopic] = useState(() => localStorage.getItem('topic') || '');
         const [host, setHost] = useState(() => localStorage.getItem('host') || 'Host');
         const [guest, setGuest] = useState(() => localStorage.getItem('guest') || 'Gast');
         const [rss, setRss] = useState([]);
         const [src, setSrc] = useState([]);

         useEffect(() => localStorage.setItem('script', script), [script]);
         useEffect(() => localStorage.setItem('topic', topic), [topic]);
         useEffect(() => localStorage.setItem('host', host), [host]);
         useEffect(() => localStorage.setItem('guest', guest), [guest]);

         return (
            <div className="container mx-auto max-w-4xl bg-white rounded-2xl shadow overflow-hidden">
               <div className="bg-white p-10 text-center border-b-2 border-[#c0ae66] relative">
                  <div className="relative z-10">
                     <img src="https://anyever.de/wp-content/themes/anyever/static/images/logo-anyever-gold.svg" className="w-48 mx-auto mb-2"/>
                     <div className="text-sm tracking-widest uppercase mb-1">ENJOY.AUDIO</div>
                     <h1 className="text-3xl font-light tracking-widest">Podcast Generator</h1>
                  </div>
               </div>
               <div className="bg-[#f9f9f9] p-8 space-y-8">
                  <ScriptSection 
                    onScriptReady={setScript} 
                    hostName={host} setHostName={setHost} 
                    guestName={guest} setGuestName={setGuest} 
                    topic={topic} setTopic={setTopic}
                    setRssArticles={setRss} setSearchSources={setSrc}
                  />
                  <AudioSection 
                    script={script} 
                    hostName={host} guestName={guest} 
                    topic={topic} rssArticles={rss} searchSources={src}
                  />
               </div>
            </div>
         );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>