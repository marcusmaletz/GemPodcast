<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ANY EVER | Podcast Generator</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LameJS for MP3 Encoding -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Babel Standalone with TS support -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      :root {
        --any-ever-white: #ffffff;
        --any-ever-black: #181818;
        --any-ever-gold: #c0ae66;
        --any-ever-dark-grey: #333333;
        --any-ever-stone-grey: #e5e5e5;
        --any-ever-light-grey: #717684;
        --any-ever-bright-grey: #f9f9f9;
        --border-light: rgba(0,0,0,0.05);
        --font-weight-medium: 500;
        --font-weight-bold: 700;
        --letter-spacing-medium: 0.05em;
        --letter-spacing-normal: 0.01em;
        --shadow-gold: 0 8px 18px rgba(192,174,102,0.24);
        --gradient-gold: linear-gradient(135deg, #d4c585 0%, #c0ae66 100%);
      }

      body {
        font-family: 'Inter', sans-serif;
        background-color: var(--any-ever-bright-grey);
        color: var(--any-ever-black);
        margin: 0;
        padding: 24px;
      }

      /* Custom Scrollbar */
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

      h1, h2, h3, h4 { font-weight: var(--font-weight-medium); letter-spacing: var(--letter-spacing-normal); }

      .btn-primary {
        background: var(--gradient-gold);
        color: white;
        box-shadow: var(--shadow-gold);
        transition: all 0.2s ease;
      }
      .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(192,174,102,0.3); }
      .btn-primary:disabled { background: var(--any-ever-stone-grey); box-shadow: none; transform: none; cursor: not-allowed; }

      .card {
        background: var(--any-ever-white);
        border: 1px solid rgba(0,0,0,0.05);
        border-radius: 16px;
        box-shadow: 0 4px 18px rgba(0,0,0,0.04);
      }
      
      .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      
      #error-log {
        display: none;
        position: fixed; top: 0; left: 0; width: 100%; background: #fee2e2; color: #991b1b; padding: 20px; z-index: 9999; border-bottom: 1px solid #ef4444; font-family: monospace; white-space: pre-wrap; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }
    </style>

    <!-- Import Map for external libraries -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.344.0",
    "@google/genai": "https://esm.sh/@google/genai@0.1.1",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
  </head>
  <body>
    <div id="error-log"></div>
    <div id="root"></div>
    
    <script>
        // GLOBAL ERROR HANDLER
        window.onerror = function(msg, url, line, col, error) {
            const div = document.getElementById('error-log');
            if(div) {
                div.style.display = 'block';
                div.innerText = `APP CRASH:\n${msg}\nFile: ${url}\nLine: ${line}\nCheck console for details.`;
            }
            console.error("Global Error:", error);
        };
        
        // POLYFILLS
        window.process = { env: { API_KEY: '' } }; 
        window.Buffer = {
            from: (str, encoding) => {
                if (encoding === 'base64') {
                    const bin = atob(str);
                    const arr = new Uint8Array(bin.length);
                    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
                    return arr;
                }
                return new TextEncoder().encode(str);
            }
        };
    </script>

    <!-- MONOLITHIC APP CODE INLINED -->
    <script type="text/babel" data-type="module" data-presets="react,typescript">
      import React, { useState, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { 
        Sparkles, Users, Globe, Settings, ChevronUp, ChevronDown, RotateCcw, 
        Rss, Plus, Trash2, ExternalLink, Mic, Play, Volume2, Disc, 
        Music, Upload, Save, CheckCircle2, Mail, Download, FileAudio, X, Send, Loader2, Square 
      } from 'lucide-react';
      import { GoogleGenAI, Modality, HarmCategory, HarmBlockThreshold } from "@google/genai";

      // ==========================================
      // 1. CONFIG & TYPES
      // ==========================================

      const N8N_WEBHOOK_URL = 'https://anymal.app.n8n.cloud/webhook/send_mail';
      const API_KEY = process.env.API_KEY; 

      enum VoiceName {
        Puck = 'Puck',
        Charon = 'Charon',
        Kore = 'Kore',
        Fenrir = 'Fenrir',
        Zephyr = 'Zephyr',
      }

      interface RssArticle {
        title: string;
        description: string;
        link: string;
        source: string;
      }

      interface GeneratedScriptResponse {
        title: string;
        script: string;
        searchSources?: { title: string; uri: string }[];
      }

      interface StoredAudioFile {
        name: string;
        blob: Blob;
      }

      type MusicSlotIndex = -1 | 0 | 1 | 2;


      // ==========================================
      // 2. AUDIO UTILS
      // ==========================================

      const decodeBase64Audio = async (base64String: string, ctx: AudioContext): Promise<AudioBuffer> => {
        const binaryString = atob(base64String);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
        
        let bufferToUse = bytes.buffer;
        if (bytes.byteLength % 2 !== 0) bufferToUse = bytes.buffer.slice(0, bytes.byteLength - 1);
        
        const dataInt16 = new Int16Array(bufferToUse);
        const numChannels = 1;
        const sampleRate = 24000; 
        const frameCount = dataInt16.length / numChannels;
        
        const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);
        const channelData = buffer.getChannelData(0);
        
        for (let i = 0; i < frameCount; i++) channelData[i] = dataInt16[i] / 32768.0;
        return buffer;
      };

      const decodeAudioBlob = async (blob: Blob, ctx: AudioContext): Promise<AudioBuffer> => {
        const arrayBuffer = await blob.arrayBuffer();
        return await ctx.decodeAudioData(arrayBuffer);
      };

      const mixPodcastSequence = async (
        voiceBuffer: AudioBuffer,
        backgroundBuffer: AudioBuffer | null,
        introBuffer: AudioBuffer | null,
        outroBuffer: AudioBuffer | null,
        musicVolume: number,
        introVolume: number,
        outroVolume: number
      ): Promise<AudioBuffer> => {
        const outputSampleRate = 44100; 
        const numberOfChannels = 2; 
        const introDur = introBuffer ? introBuffer.duration : 0;
        const voiceDur = voiceBuffer.duration;
        const outroDur = outroBuffer ? outroBuffer.duration : 0;
        const totalDuration = introDur + voiceDur + outroDur;
        const safeDuration = Math.max(totalDuration, 0.001);
        const length = Math.ceil(safeDuration * outputSampleRate);
        const offlineCtx = new OfflineAudioContext(numberOfChannels, length, outputSampleRate);

        const createSource = (buffer: AudioBuffer, vol: number, startTime: number, stopTime?: number, loop: boolean = false) => {
          const safeVol = isFinite(vol) && vol >= 0 ? vol : 0;
          const source = offlineCtx.createBufferSource();
          source.buffer = buffer;
          source.loop = loop;
          const gainNode = offlineCtx.createGain();
          gainNode.gain.value = safeVol;
          source.connect(gainNode);
          gainNode.connect(offlineCtx.destination);
          source.start(startTime);
          if (stopTime !== undefined && stopTime > startTime) source.stop(stopTime);
          return source;
        };

        if (introBuffer) createSource(introBuffer, introVolume, 0);
        createSource(voiceBuffer, 1.0, introDur);
        if (backgroundBuffer) createSource(backgroundBuffer, musicVolume, introDur, introDur + voiceDur, true);
        if (outroBuffer) createSource(outroBuffer, outroVolume, introDur + voiceDur);

        return await offlineCtx.startRendering();
      };

      const audioBufferToMp3 = (buffer: AudioBuffer): Blob => {
        // @ts-ignore
        const lamejs = window.lamejs;
        if (!lamejs) throw new Error("Lamejs library not found. Check internet connection.");
        const channels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        const kbps = 320; 
        const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, kbps);
        const mp3Data: Int8Array[] = [];
        const rawLeft = buffer.getChannelData(0);
        const rawRight = channels > 1 ? buffer.getChannelData(1) : rawLeft;
        const length = rawLeft.length;
        const sampleBlockSize = 1152; 
        const leftInt16 = new Int16Array(sampleBlockSize);
        const rightInt16 = new Int16Array(sampleBlockSize);
        
        for (let i = 0; i < length; i += sampleBlockSize) {
          const chunkLen = Math.min(sampleBlockSize, length - i);
          for (let j = 0; j < chunkLen; j++) {
            const l = Math.max(-1, Math.min(1, rawLeft[i + j]));
            const r = Math.max(-1, Math.min(1, rawRight[i + j]));
            leftInt16[j] = (l < 0 ? l * 32768 : l * 32767);
            rightInt16[j] = (r < 0 ? r * 32768 : r * 32767);
          }
          const leftChunk = (chunkLen === sampleBlockSize) ? leftInt16 : leftInt16.subarray(0, chunkLen);
          const rightChunk = (chunkLen === sampleBlockSize) ? rightInt16 : rightInt16.subarray(0, chunkLen);
          const mp3buf = (channels === 1) ? mp3encoder.encodeBuffer(leftChunk) : mp3encoder.encodeBuffer(leftChunk, rightChunk);
          if (mp3buf.length > 0) mp3Data.push(mp3buf);
        }
        const mp3buf = mp3encoder.flush();
        if (mp3buf.length > 0) mp3Data.push(mp3buf);
        return new Blob(mp3Data, { type: 'audio/mp3' });
      };

      const audioBufferToWav = (buffer: AudioBuffer): Blob => {
        const numOfChan = buffer.numberOfChannels;
        const length = buffer.length * numOfChan * 2 + 44;
        const bufferArr = new ArrayBuffer(length);
        const view = new DataView(bufferArr);
        const channels = [];
        let i, sample, offset = 0, pos = 0;
        const setUint16 = (data: number) => { view.setUint16(pos, data, true); pos += 2; };
        const setUint32 = (data: number) => { view.setUint32(pos, data, true); pos += 4; };

        setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157); 
        setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
        setUint32(buffer.sampleRate); setUint32(buffer.sampleRate * 2 * numOfChan); 
        setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4); 

        for (i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));

        while (pos < buffer.length) {
          for (i = 0; i < numOfChan; i++) {
            sample = Math.max(-1, Math.min(1, channels[i][pos])); 
            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; 
            view.setInt16(44 + offset, sample, true); 
            offset += 2;
          }
          pos++;
        }
        return new Blob([bufferArr], { type: "audio/wav" });
      };

      const blobToBase64 = (blob: Blob): Promise<string> => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            if (typeof reader.result === 'string') {
              const base64 = reader.result.split(',')[1];
              resolve(base64);
            } else reject(new Error('Failed to convert blob to base64'));
          };
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      };

      // --- STORAGE UTILS (IndexedDB) ---

      const DB_NAME = 'GeminiPodcastStudioDB';
      const STORE_NAME = 'audioFiles';
      const DB_VERSION = 1;
      const openDB = (): Promise<IDBDatabase> => {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event: any) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
          };
        });
      };
      const storeAudioFile = async (key: string, file: File): Promise<void> => {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORE_NAME);
          store.put({ name: file.name, blob: file }, key);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      };
      const getAudioFile = async (key: string): Promise<{ name: string, blob: Blob } | null> => {
        try {
          const db = await openDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const store = tx.objectStore(STORE_NAME);
            const req = store.get(key);
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => reject(req.error);
          });
        } catch (err) { return null; }
      };
      const deleteAudioFile = async (key: string): Promise<void> => {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORE_NAME);
          store.delete(key);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      };


      // ==========================================
      // 3. RSS UTILS
      // ==========================================

      const fetchFeedContent = async (url: string): Promise<string | null> => {
        const cleanUrl = url.trim();
        const encodedUrl = encodeURIComponent(cleanUrl);
        try {
          const response = await fetch(`https://api.allorigins.win/get?url=${encodedUrl}`);
          if (response.ok) {
            const data = await response.json();
            if (data.contents) return data.contents;
          }
        } catch (e) { console.warn(`AllOrigins proxy failed`, e); }
        try {
          const response = await fetch(`https://corsproxy.io/?${encodedUrl}`);
          if (response.ok) return await response.text();
        } catch (e) { console.warn(`CorsProxy failed`, e); }
        return null;
      };

      const fetchRssFeeds = async (urls: string[]): Promise<{ combinedContent: string, articles: RssArticle[] }> => {
        if (urls.length === 0) return { combinedContent: "", articles: [] };
        let combinedContent = "RSS FEED QUELLEMATERIAL (STRICT USE ONLY):\n";
        const allArticles: RssArticle[] = [];
        const validUrls = urls.filter(u => u.trim().length > 0);

        for (const url of validUrls) {
          try {
            const xmlString = await fetchFeedContent(url);
            if (!xmlString) {
              combinedContent += `\n(Fehler beim Laden des Feeds: ${url})\n`;
              continue;
            }
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "text/xml");
            if (xmlDoc.querySelector("parsererror")) {
              combinedContent += `\n(Fehler beim Lesen des XML-Formats fÃ¼r: ${url})\n`;
              continue;
            }
            let channelTitle = "Unbekannte Quelle";
            const titleNode = xmlDoc.querySelector("channel > title") || xmlDoc.querySelector("feed > title");
            if (titleNode && titleNode.textContent) channelTitle = titleNode.textContent.trim();

            const items = Array.from(xmlDoc.querySelectorAll("item, entry")).slice(0, 5);
            combinedContent += `\n=== QUELLE: ${channelTitle} ===\n`;

            items.forEach(item => {
              const title = item.querySelector("title")?.textContent?.trim() || "Ohne Titel";
              const contentEncoded = item.getElementsByTagName("content:encoded")[0]?.textContent;
              const description = item.querySelector("description")?.textContent;
              const summary = item.querySelector("summary")?.textContent;
              const content = item.querySelector("content")?.textContent;
              
              let fullText = contentEncoded || content || description || summary || "";
              fullText = fullText.replace(/<[^>]*>?/gm, ' ').replace(/\s+/g, ' ').trim();
              
              let link = "";
              const atomLinks = item.getElementsByTagName("link");
              if (atomLinks.length > 0) {
                  for (let i = 0; i < atomLinks.length; i++) {
                      const href = atomLinks[i].getAttribute("href");
                      if (href) { link = href; break; }
                      if (atomLinks[i].textContent && atomLinks[i].textContent?.startsWith('http')) {
                          link = atomLinks[i].textContent?.trim() || "";
                          break;
                      }
                  }
              }
              if (!link) {
                   const directLink = item.querySelector("link")?.textContent?.trim();
                   if (directLink && directLink.startsWith('http')) link = directLink;
              }
              if (!link) {
                  const idNode = item.querySelector("guid, id");
                  const idText = idNode?.textContent?.trim();
                  if (idText && (idText.startsWith("http") || idText.startsWith("https"))) link = idText;
              }
              if (!link) {
                  const html = item.innerHTML;
                  const urlMatch = html.match(/<link>(https?:\/\/[^<]+)<\/link>/i);
                  if (urlMatch && urlMatch[1]) link = urlMatch[1];
              }

              const articleObj: RssArticle = {
                title,
                description: fullText.substring(0, 300), 
                link: link || "Link nicht gefunden",
                source: channelTitle
              };
              allArticles.push(articleObj);
              
              combinedContent += `\n- ARTIKEL: "${title}"\n  QUELLE: ${channelTitle}\n  LINK: ${link}\n`; 
              if (fullText) {
                 const analysisText = fullText.length > 2500 ? fullText.substring(0, 2500) + "..." : fullText;
                 combinedContent += `  INHALT: ${analysisText}\n`;
              }
            });
          } catch (error) { console.error(`Failed to process RSS feed: ${url}`, error); }
        }
        return { combinedContent, articles: allArticles };
      };


      // ==========================================
      // 4. GEMINI SERVICE
      // ==========================================

      const ai = new GoogleGenAI({ apiKey: API_KEY || '' });

      const generateScript = async (
        topic: string,
        hostName: string,
        guestName: string,
        useSearch: boolean = false,
        rssContent: string = "",
        customSystemInstruction?: string
      ): Promise<GeneratedScriptResponse> => {
        try {
          const modelId = "gemini-2.5-flash";
          const defaultSystemInstruction = `Du bist ein professioneller, investigativer Podcast-Produzent.
      Deine Aufgabe ist es, einen tiefgrÃ¼ndigen, spannenden Podcast-Dialog basierend auf dem Thema und den bereitgestellten Quellen zu schreiben.
      WICHTIGE REGELN FÃœR DEN INHALT:
      1. **SPRACHE**: Der gesamte Dialog muss zwingend auf DEUTSCH verfasst sein.
      2. **KEIN OBERFLÃ„CHLICHER SMALLTALK**: Analysiere die AUSWIRKUNGEN und HINTERGRÃœNDE.
      3. **DISKUSSION**: Der Host und der Gast sollten leicht unterschiedliche Perspektiven haben oder kritische Nachfragen stellen.
      4. **NATÃœRLICHKEIT**: Es soll wie ein echtes GesprÃ¤ch klingen, nicht wie vorgelesen.
      Formatierung:
      1. Das Skript muss ein Dialog sein.
      2. Nutze exakt die vorgegebenen Sprechernamen als PrÃ¤fix (z.B. "${hostName}:", "${guestName}:").
      3. LÃ¤nge: ca. 400-600 WÃ¶rter.
      4. Starte sofort mit dem Dialog.`;

          const systemInstruction = customSystemInstruction || defaultSystemInstruction;
          let userPrompt = `Thema: "${topic}"\nSprecher 1 (Host): "${hostName}"\nSprecher 2 (Gast): "${guestName}"\n`;

          if (rssContent) {
            userPrompt += `\nACHTUNG: RSS-MODUS AKTIV. NUTZE NUR DIE FOLGENDEN QUELLEN:\n==================================================\n${rssContent}\n==================================================\n`;
            userPrompt += `\nSCHRITT 1: REDAKTIONELLE PRÃœFUNG & KURATIERUNG:\n1. **DEDUPLIZIERUNG**: Fasse gleiche Events zusammen.\n2. **RELEVANZ-FILTER**: Ignoriere Bugfixes und Werbung. WÃ¤hle nur Top 3-4 Themen.\n`;
            userPrompt += `\nSCHRITT 2: SCHREIBEN:\n1. Nutze AUSSCHLIESSLICH die RSS-Inhalte. KEIN externes Wissen.\n2. ZITIERPFLICHT: Nenne die Quelle verbal (z.B. "Laut Heise Online...").\n`;
          }
          userPrompt += `\n\nGeneriere jetzt das Skript basierend auf deiner redaktionellen Auswahl. WICHTIG: Schreibe den Dialog komplett auf DEUTSCH.`;

          const config: any = {
            temperature: 0.3,
            systemInstruction: systemInstruction,
          };
          if (useSearch) {
            config.tools = [{ googleSearch: {} }];
          }

          const response = await ai.models.generateContent({
            model: modelId,
            contents: userPrompt,
            config: config
          });

          const text = response.text || "";
          let searchSources: { title: string; uri: string }[] = [];
          const chunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
          if (chunks) {
            chunks.forEach((chunk: any) => {
              if (chunk.web) searchSources.push({ title: chunk.web.title, uri: chunk.web.uri });
            });
          }

          const dateStr = new Date().toLocaleDateString('de-DE');
          const shortTopic = topic.length > 30 ? topic.substring(0, 27) + "..." : topic;
          return {
            title: `AI-Podcast: ${shortTopic} - ${dateStr}`,
            script: text,
            searchSources
          };
        } catch (e) { console.error(e); throw e; }
      };

      const generateVoicePreview = async (voice: VoiceName, text: string): Promise<string> => {
        const response = await ai.models.generateContent({
          model: "gemini-2.5-flash-preview-tts",
          contents: [{ parts: [{ text: text }] }],
          config: {
            responseModalities: [Modality.AUDIO],
            speechConfig: {
              voiceConfig: { prebuiltVoiceConfig: { voiceName: voice } }
            }
          }
        });
        const parts = response.candidates?.[0]?.content?.parts;
        if (!parts || !parts[0].inlineData) throw new Error("No audio content generated.");
        return parts[0].inlineData.data;
      };

      const generatePodcastAudio = async (script: string, hostName: string, guestName: string, hostVoice: VoiceName, guestVoice: VoiceName): Promise<string> => {
        const cleanedScript = script.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1');
        const response = await ai.models.generateContent({
          model: "gemini-2.5-flash-preview-tts",
          contents: [{ parts: [{ text: cleanedScript }] }],
          config: {
            responseModalities: [Modality.AUDIO],
            speechConfig: {
              multiSpeakerVoiceConfig: {
                speakerVoiceConfigs: [
                  { speaker: hostName, voiceConfig: { prebuiltVoiceConfig: { voiceName: hostVoice } } },
                  { speaker: guestName, voiceConfig: { prebuiltVoiceConfig: { voiceName: guestVoice } } }
                ]
              }
            },
            safetySettings: [
              { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
              { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
              { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
              { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH }
            ]
          }
        });
        const parts = response.candidates?.[0]?.content?.parts;
        if (!parts || !parts[0].inlineData) throw new Error(`No audio generated. Reason: ${response.candidates?.[0]?.finishReason}`);
        return parts[0].inlineData.data;
      };


      // ==========================================
      // 5. COMPONENTS
      // ==========================================

      const ScriptSection: React.FC<{
        onScriptReady: (script: string) => void;
        hostName: string;
        setHostName: (name: string) => void;
        guestName: string;
        setGuestName: (name: string) => void;
        topic: string;
        setTopic: (topic: string) => void;
        setRssArticles: (articles: RssArticle[]) => void;
        setSearchSources: (sources: { title: string; uri: string }[]) => void;
      }> = ({ onScriptReady, hostName, setHostName, guestName, setGuestName, topic, setTopic, setRssArticles, setSearchSources }) => {
        const [loading, setLoading] = useState(false);
        const [loadingStatus, setLoadingStatus] = useState<string>("");
        const [useSearch, setUseSearch] = useState(() => localStorage.getItem('useSearch') === 'true');
        const [useRss, setUseRss] = useState(() => localStorage.getItem('useRss') === 'true');
        const [showRssInput, setShowRssInput] = useState(false);
        const [rssFeeds, setRssFeeds] = useState<string[]>(() => {
          try { return JSON.parse(localStorage.getItem('rssFeedsList') || '[]'); } catch { return []; }
        });
        const [newRssInput, setNewRssInput] = useState('');
        const [currentScript, setCurrentScript] = useState('');
        const [sources, setSources] = useState<{ title: string; uri: string }[]>([]);
        const [localRssArticles, setLocalRssArticles] = useState<RssArticle[]>([]);
        const [showSettings, setShowSettings] = useState(false);
        const [systemInstruction, setSystemInstruction] = useState(() => localStorage.getItem('systemInstruction') || "");

        useEffect(() => { localStorage.setItem('useSearch', useSearch.toString()); }, [useSearch]);
        useEffect(() => { localStorage.setItem('useRss', useRss.toString()); if(useRss) setShowRssInput(true); }, [useRss]);
        useEffect(() => { localStorage.setItem('rssFeedsList', JSON.stringify(rssFeeds)); }, [rssFeeds]);
        useEffect(() => { localStorage.setItem('systemInstruction', systemInstruction); }, [systemInstruction]);

        const handleAddRssFeed = () => {
          if (newRssInput.trim() && !rssFeeds.includes(newRssInput.trim())) {
            setRssFeeds([...rssFeeds, newRssInput.trim()]);
          }
          setNewRssInput('');
        };

        const handleGenerate = async () => {
          if (!topic.trim() || !hostName.trim() || !guestName.trim()) return;
          setLoading(true);
          setSources([]); setSearchSources([]); setLocalRssArticles([]); setRssArticles([]);
          let rssContent = "";
          try {
            if (useRss && rssFeeds.length > 0) {
              setLoadingStatus("Lese & Analysiere RSS Feeds...");
              const { combinedContent, articles } = await fetchRssFeeds(rssFeeds);
              rssContent = combinedContent;
              setRssArticles(articles); setLocalRssArticles(articles);
            }
            setLoadingStatus("Schreibe Deep Dive Skript...");
            const result = await generateScript(topic, hostName, guestName, useSearch, rssContent, systemInstruction);
            setCurrentScript(result.script);
            if (result.searchSources) { setSources(result.searchSources); setSearchSources(result.searchSources); }
            onScriptReady(result.script);
          } catch (error) {
            console.error(error);
            alert("Fehler beim Generieren des Skripts.");
          } finally {
            setLoading(false); setLoadingStatus("");
          }
        };

        return (
          <div className="card p-8 transition-all hover:shadow-lg">
            <div className="border-b border-[#c0ae66] pb-4 mb-6">
              <h2 className="text-xl font-medium text-[#181818] flex items-center gap-2 tracking-wide">
                <Sparkles className="w-5 h-5 text-[#c0ae66]" /> SCHRITT 1: SKRIPT GENERIEREN
              </h2>
            </div>
            <div className="space-y-6">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                  <label className="block text-xs font-medium text-[#181818] uppercase tracking-wider mb-2">Name Sprecher 1</label>
                  <input type="text" value={hostName} onChange={(e) => setHostName(e.target.value)} className="w-full rounded-xl py-3 px-4 border border-gray-200" />
                </div>
                <div>
                  <label className="block text-xs font-medium text-[#181818] uppercase tracking-wider mb-2">Name Sprecher 2</label>
                  <input type="text" value={guestName} onChange={(e) => setGuestName(e.target.value)} className="w-full rounded-xl py-3 px-4 border border-gray-200" />
                </div>
              </div>
              <div>
                  <label className="block text-xs font-medium text-[#181818] uppercase tracking-wider mb-2">Podcast Thema</label>
                  <input type="text" value={topic} onChange={(e) => setTopic(e.target.value)} className="w-full rounded-xl py-3 px-4 border border-gray-200" />
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <label className="flex items-center gap-3 p-4 rounded-2xl bg-[#f9f9f9] border border-dashed border-[#d1d5db] cursor-pointer">
                    <input type="checkbox" checked={useSearch} onChange={(e) => setUseSearch(e.target.checked)} className="w-4 h-4 accent-[#c0ae66]" />
                    <span className="text-sm font-medium text-[#181818]">Google Search Grounding</span>
                  </label>
                  <label className="flex items-center gap-3 p-4 rounded-2xl bg-[#f9f9f9] border border-dashed border-[#d1d5db] cursor-pointer">
                    <input type="checkbox" checked={useRss} onChange={(e) => {setUseRss(e.target.checked); if(e.target.checked) setShowRssInput(true);}} className="w-4 h-4 accent-[#c0ae66]" />
                    <span className="text-sm font-medium text-[#181818]">RSS Feeds einbinden</span>
                  </label>
              </div>
              {useRss && showRssInput && (
                  <div className="bg-white border border-[rgba(0,0,0,0.08)] rounded-2xl p-6 shadow-sm space-y-4">
                    <div className="flex gap-2">
                      <input type="text" value={newRssInput} onChange={(e) => setNewRssInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && handleAddRssFeed()} placeholder="Feed URL..." className="flex-1 rounded-full px-4 py-2 text-sm border border-gray-200" />
                      <button onClick={handleAddRssFeed} className="btn-primary w-10 h-10 rounded-full flex items-center justify-center"><Plus className="w-5 h-5" /></button>
                    </div>
                    <ul className="space-y-2 max-h-40 overflow-y-auto">
                      {rssFeeds.map((url, idx) => (
                        <li key={idx} className="flex items-center justify-between bg-[#f9f9f9] px-4 py-2 rounded-xl text-sm">
                          <span className="truncate mr-2">{url}</span>
                          <button onClick={() => {const n=[...rssFeeds]; n.splice(idx,1); setRssFeeds(n);}} className="text-[#717684] hover:text-[#c0392b]"><Trash2 className="w-4 h-4" /></button>
                        </li>
                      ))}
                    </ul>
                  </div>
              )}
              <div className="flex justify-end">
                  <button onClick={() => setShowSettings(!showSettings)} className="flex items-center gap-2 text-xs text-[#717684] bg-[#f9f9f9] px-3 py-1.5 rounded-full">
                      <Settings className="w-3 h-3" /> {showSettings ? 'Einstellungen verbergen' : 'Erweiterte Einstellungen'}
                  </button>
              </div>
              {showSettings && (
                  <div className="bg-[#f9f9f9] border border-[rgba(0,0,0,0.05)] rounded-2xl p-6">
                      <div className="flex justify-between mb-2"><label className="text-xs font-bold uppercase">System Prompt</label><button onClick={() => setSystemInstruction("")} className="text-xs text-[#c0ae66]"><RotateCcw className="w-3 h-3 inline"/> Reset</button></div>
                      <textarea value={systemInstruction} onChange={(e) => setSystemInstruction(e.target.value)} rows={6} className="w-full rounded-xl p-3 text-xs font-mono border border-gray-200" />
                  </div>
              )}
              <button onClick={handleGenerate} disabled={loading || !topic} className="btn-primary w-full flex items-center justify-center gap-2 px-8 py-4 rounded-full font-bold uppercase text-sm">
                  {loading ? <><Loader2 className="w-4 h-4 animate-spin" /> {loadingStatus || "Generiere..."}</> : <><Sparkles className="w-4 h-4" /> Skript Generieren</>}
              </button>
              {currentScript && (
                <div className="pt-8 border-t border-[rgba(0,0,0,0.05)]">
                  <textarea value={currentScript} onChange={(e) => {setCurrentScript(e.target.value); onScriptReady(e.target.value);}} rows={12} className="w-full bg-white border border-[rgba(0,0,0,0.08)] rounded-2xl p-6 font-mono text-sm shadow-inner" />
                  {localRssArticles.length > 0 && (
                    <div className="mt-6 bg-[#f9f9f9] p-6 rounded-2xl border border-[rgba(0,0,0,0.05)]">
                      <h4 className="text-xs font-bold text-[#c0ae66] uppercase mb-4 border-b border-[#c0ae66] pb-2 inline-block">Verwendete RSS-Quellen</h4>
                      <ul className="space-y-3">{localRssArticles.map((a, i) => (
                          <li key={i} className="flex flex-col gap-1 text-sm">
                            <div className="font-medium flex gap-2"><Rss className="w-4 h-4 text-[#c0ae66]"/> {a.title}</div>
                            <div className="text-xs text-[#717684] pl-6"><span className="uppercase font-semibold">{a.source}</span> â€¢ <a href={a.link} target="_blank" className="text-[#c0ae66] hover:underline">Artikel Ã¶ffnen <ExternalLink className="w-3 h-3 inline"/></a></div>
                          </li>
                      ))}</ul>
                    </div>
                  )}
                  {sources.length > 0 && (
                    <div className="mt-6 bg-[#f9f9f9] p-6 rounded-2xl border border-[rgba(0,0,0,0.05)]">
                      <h4 className="text-xs font-bold text-[#c0ae66] uppercase mb-4 border-b border-[#c0ae66] pb-2 inline-block">Google Search Quellen</h4>
                      <ul className="space-y-2">{sources.map((s, i) => <li key={i} className="flex gap-2 text-sm"><Globe className="w-4 h-4 text-[#c0ae66]"/><a href={s.uri} target="_blank" className="hover:text-[#c0ae66] hover:underline truncate">{s.title || s.uri}</a></li>)}</ul>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        );
      };

      const AudioSection: React.FC<{ script: string, hostName: string, guestName: string, topic: string, rssArticles?: RssArticle[], searchSources?: { title: string; uri: string }[] }> = ({ script, hostName, guestName, topic, rssArticles, searchSources }) => {
        const [hostVoice, setHostVoice] = useState<VoiceName>(() => (localStorage.getItem('hostVoice') as VoiceName) || VoiceName.Kore);
        const [guestVoice, setGuestVoice] = useState<VoiceName>(() => (localStorage.getItem('guestVoice') as VoiceName) || VoiceName.Puck);
        const [introFile, setIntroFile] = useState<StoredAudioFile | null>(null);
        const [outroFile, setOutroFile] = useState<StoredAudioFile | null>(null);
        const [musicSlots, setMusicSlots] = useState<(StoredAudioFile | null)[]>([null, null, null]);
        const [selectedMusicIndex, setSelectedMusicIndex] = useState<MusicSlotIndex>(() => parseInt(localStorage.getItem('selectedMusicIndex') || '-1') as MusicSlotIndex);
        const [musicVolume, setMusicVolume] = useState(() => parseFloat(localStorage.getItem('musicVolume') || '0.1'));
        const [introVolume, setIntroVolume] = useState(() => parseFloat(localStorage.getItem('introVolume') || '0.5'));
        const [outroVolume, setOutroVolume] = useState(() => parseFloat(localStorage.getItem('outroVolume') || '0.5'));
        
        const [loading, setLoading] = useState(false);
        const [audioUrl, setAudioUrl] = useState<string | null>(null);
        const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
        const [error, setError] = useState<string | null>(null);
        const [previewLoading, setPreviewLoading] = useState<string | null>(null);
        const [playingPreview, setPlayingPreview] = useState<string | null>(null);
        const previewAudioRef = useRef<HTMLAudioElement | null>(null);
        const [showEmailModal, setShowEmailModal] = useState(false);
        const [emailTo, setEmailTo] = useState('');
        const [emailSubject, setEmailSubject] = useState('');
        const [emailBody, setEmailBody] = useState('');
        const [isSendingEmail, setIsSendingEmail] = useState(false);
        const [emailSentSuccess, setEmailSentSuccess] = useState(false);
        const [saveStatus, setSaveStatus] = useState<'idle'|'saved'>('idle');

        useEffect(() => {
          getAudioFile('intro').then(setIntroFile);
          getAudioFile('outro').then(setOutroFile);
          Promise.all([getAudioFile('music_0'), getAudioFile('music_1'), getAudioFile('music_2')]).then(setMusicSlots);
        }, []);

        useEffect(() => { localStorage.setItem('hostVoice', hostVoice); }, [hostVoice]);
        useEffect(() => { localStorage.setItem('guestVoice', guestVoice); }, [guestVoice]);
        useEffect(() => { localStorage.setItem('selectedMusicIndex', selectedMusicIndex.toString()); }, [selectedMusicIndex]);
        useEffect(() => { localStorage.setItem('musicVolume', musicVolume.toString()); }, [musicVolume]);
        useEffect(() => { localStorage.setItem('introVolume', introVolume.toString()); }, [introVolume]);
        useEffect(() => { localStorage.setItem('outroVolume', outroVolume.toString()); }, [outroVolume]);

        const handleManualSave = () => {
          localStorage.setItem('hostVoice', hostVoice);
          localStorage.setItem('guestVoice', guestVoice);
          localStorage.setItem('selectedMusicIndex', selectedMusicIndex.toString());
          localStorage.setItem('musicVolume', musicVolume.toString());
          localStorage.setItem('introVolume', introVolume.toString());
          localStorage.setItem('outroVolume', outroVolume.toString());
          setSaveStatus('saved'); setTimeout(()=>setSaveStatus('idle'), 2000);
        };

        const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>, type: 'intro' | 'outro' | 'music', index?: number) => {
          if (e.target.files?.[0]) {
            const file = e.target.files[0];
            if (type === 'intro') { await storeAudioFile('intro', file); setIntroFile({ name: file.name, blob: file }); }
            else if (type === 'outro') { await storeAudioFile('outro', file); setOutroFile({ name: file.name, blob: file }); }
            else if (type === 'music' && index !== undefined) {
              await storeAudioFile(`music_${index}`, file);
              const s = [...musicSlots]; s[index] = { name: file.name, blob: file }; setMusicSlots(s); setSelectedMusicIndex(index as MusicSlotIndex);
            }
          }
        };
        
        const handleFileDelete = async (type: 'intro' | 'outro' | 'music', index?: number) => {
          if (type === 'intro') { await deleteAudioFile('intro'); setIntroFile(null); }
          else if (type === 'outro') { await deleteAudioFile('outro'); setOutroFile(null); }
          else if (type === 'music' && index !== undefined) { await deleteAudioFile(`music_${index}`); const s = [...musicSlots]; s[index] = null; setMusicSlots(s); if(selectedMusicIndex===index) setSelectedMusicIndex(-1); }
        };

        const playPreview = (blob: Blob, id: string) => {
          if (previewAudioRef.current) { previewAudioRef.current.pause(); previewAudioRef.current = null; }
          if (playingPreview === id) { setPlayingPreview(null); return; }
          const url = URL.createObjectURL(blob);
          const audio = new Audio(url);
          audio.onended = () => { setPlayingPreview(null); URL.revokeObjectURL(url); };
          previewAudioRef.current = audio;
          audio.play();
          setPlayingPreview(id);
        };

        const handleVoicePreview = async (voice: VoiceName, id: 'host' | 'guest') => {
          if (playingPreview === id) { playPreview(new Blob(), id); return; } // Stop
          setPreviewLoading(id);
          try {
            const b64 = await generateVoicePreview(voice, `Hallo, ich bin ${voice}.`);
            const ctx = new AudioContext();
            const buf = await decodeBase64Audio(b64, ctx);
            playPreview(audioBufferToWav(buf), id);
            ctx.close();
          } catch { alert("Preview failed"); } finally { setPreviewLoading(null); }
        };

        const handleGenerateAudio = async () => {
          if (!script) return;
          setLoading(true); setError(null); setAudioUrl(null); setAudioBlob(null);
          let ctx: AudioContext | null = null;
          try {
              ctx = new AudioContext();
              const vB64 = await generatePodcastAudio(script, hostName, guestName, hostVoice, guestVoice);
              const vBuf = await decodeBase64Audio(vB64, ctx);
              let mBuf = null, iBuf = null, oBuf = null;
              if (selectedMusicIndex !== -1 && musicSlots[selectedMusicIndex]) mBuf = await decodeAudioBlob(musicSlots[selectedMusicIndex]!.blob, ctx);
              if (introFile) iBuf = await decodeAudioBlob(introFile.blob, ctx);
              if (outroFile) oBuf = await decodeAudioBlob(outroFile.blob, ctx);
              const mix = await mixPodcastSequence(vBuf, mBuf, iBuf, oBuf, musicVolume, introVolume, outroVolume);
              const blob = audioBufferToMp3(mix);
              setAudioUrl(URL.createObjectURL(blob)); setAudioBlob(blob);
          } catch (e: any) { setError(e.message); } finally { ctx?.close(); setLoading(false); }
        };

        const openEmailModal = () => {
          const date = new Date().toLocaleDateString('de-DE');
          const subj = `AI-Podcast: ${topic.substring(0, 25)}... - ${date}`;
          let sources = "";
          if (rssArticles?.length) {
              sources += "\n\nðŸ”— RSS QUELLEN:\n================================";
              rssArticles.forEach(a => sources += `\nâ€¢ ${a.title} (${a.source})\n  ${a.link}`);
              sources += "\n================================";
          }
          if (searchSources?.length) {
              sources += "\n\nðŸ”— WEB QUELLEN:\n================================";
              searchSources.forEach(s => sources += `\nâ€¢ ${s.title}\n  ${s.uri}`);
              sources += "\n================================";
          }
          setEmailSubject(subj);
          setEmailBody(`Hallo,\n\nhier ist die neue Podcast-Folge Ã¼ber "${topic}".\n\nðŸŽ™ï¸ ${hostName} & ${guestName}\nðŸ“… ${date}\n\nDie MP3 ist im Anhang.${sources}\n\nBeste GrÃ¼ÃŸe,\nGemini Podcast Studio`);
          setShowEmailModal(true); setEmailSentSuccess(false);
        };

        const handleSendEmail = async () => {
          if (!emailTo || !audioBlob) return;
          setIsSendingEmail(true);
          try {
              const b64 = await blobToBase64(audioBlob);
              const payload = { to: emailTo, subject: emailSubject, body: emailBody, attachmentName: "podcast.mp3", attachmentBase64: b64 };
              let res;
              try { res = await fetch(N8N_WEBHOOK_URL, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) }); }
              catch { res = await fetch(`https://corsproxy.io/?${encodeURIComponent(N8N_WEBHOOK_URL)}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) }); }
              if (!res.ok) throw new Error("Send failed");
              setEmailSentSuccess(true); setTimeout(() => setShowEmailModal(false), 2000);
          } catch (e) { alert("Mail fail (Size limit?)"); } finally { setIsSendingEmail(false); }
        };

        return (
          <div className={`card p-8 transition-all hover:shadow-xl ${!script ? 'opacity-50 pointer-events-none' : ''}`}>
            <div className="border-b border-[#c0ae66] pb-4 mb-8 flex justify-between">
                <h2 className="text-xl font-medium flex items-center gap-2"><Volume2 className="w-5 h-5 text-[#c0ae66]"/> SCHRITT 2: AUDIO ERSTELLEN</h2>
                <button onClick={handleManualSave} className="flex items-center gap-2 px-4 py-2 rounded-full border bg-[#f9f9f9] text-xs">{saveStatus==='saved'?<><CheckCircle2 className="w-3 h-3 text-green-500"/>Gespeichert</>:<><Save className="w-3 h-3"/>Speichern</>}</button>
            </div>
            <div className="space-y-10">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {[hostVoice, guestVoice].map((voice, i) => (
                      <div key={i} className="bg-[#f9f9f9] p-4 rounded-2xl border">
                          <label className="text-xs font-medium text-[#717684] uppercase mb-2 block">{i===0?hostName:guestName}</label>
                          <div className="flex gap-3">
                              <select value={voice} onChange={(e) => i===0?setHostVoice(e.target.value as VoiceName):setGuestVoice(e.target.value as VoiceName)} className="w-full rounded-xl px-4 py-3 border border-gray-200">{Object.values(VoiceName).map(v=><option key={v} value={v}>{v}</option>)}</select>
                              <button onClick={() => handleVoicePreview(voice, i===0?'host':'guest')} className="w-12 bg-white rounded-xl flex items-center justify-center border border-gray-200">{previewLoading===(i===0?'host':'guest')?<Loader2 className="animate-spin w-4 h-4"/>:<Play className="w-4 h-4"/>}</button>
                          </div>
                      </div>
                  ))}
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {['intro', 'outro'].map((type) => {
                      const file = type==='intro'?introFile:outroFile;
                      const vol = type==='intro'?introVolume:outroVolume;
                      const setVol = type==='intro'?setIntroVolume:setOutroVolume;
                      return (
                          <div key={type} className={`rounded-2xl p-5 border ${file?'bg-[#fcfcfc] border-[#c0ae66]':'bg-[#f9f9f9]'}`}>
                              <div className="flex justify-between mb-3"><span className="capitalize font-medium">{type}</span><div className="flex gap-2">{file && <><button onClick={()=>playPreview(file.blob, type)} className="text-[#c0ae66]"><Play className="w-4 h-4"/></button><button onClick={()=>handleFileDelete(type as any)}><Trash2 className="w-4 h-4"/></button></>}</div></div>
                              <label className="block w-full bg-white border rounded-xl py-3 px-4 text-xs text-[#717684] mb-3 truncate cursor-pointer">{file?file.name:"WÃ¤hle MP3..."}<input type="file" accept="audio/*" className="hidden" onChange={(e)=>handleFileUpload(e, type as any)}/></label>
                              <div className="flex items-center gap-2"><Volume2 className="w-3 h-3"/><input type="range" min="0" max="1.2" step="0.1" value={vol} onChange={(e)=>setVol(parseFloat(e.target.value))} className="w-full h-1 accent-[#c0ae66]"/></div>
                          </div>
                      )
                  })}
              </div>
              <div>
                  <div className="flex justify-between border-b pb-2 mb-4"><h3 className="text-xs font-bold uppercase flex gap-2"><Music className="w-3 h-3"/> Hintergrund-Musik</h3><div className="flex items-center gap-2"><Volume2 className="w-3 h-3"/><input type="range" min="0" max="0.5" step="0.01" value={musicVolume} onChange={(e)=>setMusicVolume(parseFloat(e.target.value))} className="w-20 h-1 accent-[#c0ae66]"/></div></div>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                      <button onClick={()=>{setSelectedMusicIndex(-1); playPreview(new Blob(), 'none');}} className={`p-4 rounded-2xl border h-32 flex flex-col items-center justify-center ${selectedMusicIndex===-1?'border-[#c0ae66] bg-[rgba(192,174,102,0.1)]':'bg-white'}`}>Keine Musik</button>
                      {[0,1,2].map((idx) => {
                          const slot = musicSlots[idx];
                          return (
                              <div key={idx} onClick={()=>slot && setSelectedMusicIndex(idx as any)} className={`relative p-4 rounded-2xl border h-32 flex flex-col justify-between ${selectedMusicIndex===idx?'border-[#c0ae66] bg-[rgba(192,174,102,0.15)]':'bg-white hover:border-[#c0ae66]'}`}>
                                  {!slot ? <label className="w-full h-full flex flex-col items-center justify-center text-xs text-[#c0ae66] cursor-pointer border-2 border-dashed rounded-xl"><Upload className="w-4 h-4 mb-1"/>Upload<input type="file" accept="audio/*" className="hidden" onChange={(e)=>handleFileUpload(e, 'music', idx)}/></label> : 
                                  <><div className="text-xs font-medium truncate">{slot.name}</div><div className="flex justify-between mt-auto pt-2 relative z-10"><button onClick={(e)=>{e.stopPropagation(); playPreview(slot.blob, `music_${idx}`)}} className="w-8 h-8 bg-white rounded-full flex items-center justify-center shadow-sm hover:text-[#c0ae66]"><Play className="w-3 h-3"/></button><button onClick={(e)=>{e.stopPropagation(); handleFileDelete('music', idx)}} className="text-[#717684] hover:text-red-500"><Trash2 className="w-4 h-4"/></button></div></>}
                              </div>
                          )
                      })}
                  </div>
              </div>
              <div className="flex justify-end pt-8"><button onClick={handleGenerateAudio} disabled={loading} className="btn-primary px-10 py-5 rounded-full font-bold uppercase flex gap-2">{loading?<Loader2 className="animate-spin"/>:<Music/>} Podcast Generieren</button></div>
              {error && <div className="p-4 bg-red-50 text-red-500 rounded-xl text-center text-sm">{error}</div>}
              {audioUrl && (
                  <div className="bg-white rounded-2xl p-8 border border-[#c0ae66] shadow-lg animate-fade-in">
                      <div className="flex justify-between items-center mb-6">
                          <div className="flex gap-4 items-center"><div className="w-12 h-12 rounded-full bg-[#f9f9f9] border border-[#c0ae66] flex items-center justify-center text-[#c0ae66]"><Music/></div><div><h3 className="font-medium">Final Podcast</h3><p className="text-xs text-[#717684]">Ready to share</p></div></div>
                          <div className="flex gap-3"><button onClick={openEmailModal} className="px-5 py-2.5 bg-[#f9f9f9] rounded-full text-sm font-medium hover:bg-gray-200 flex gap-2"><Mail className="w-4 h-4"/> Email</button><a href={audioUrl} download="podcast.mp3" className="px-5 py-2.5 bg-[#181818] text-white rounded-full text-sm font-medium flex gap-2"><Download className="w-4 h-4"/> Download</a></div>
                      </div>
                      <audio src={audioUrl} controls className="w-full accent-[#c0ae66]"/>
                  </div>
              )}
            </div>
            {showEmailModal && (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm">
                    <div className="bg-white rounded-2xl w-full max-w-2xl shadow-2xl max-h-[90vh] flex flex-col">
                        <div className="p-6 border-b flex justify-between items-center"><h3 className="font-medium flex gap-2"><Mail className="text-[#c0ae66]"/> Senden</h3><button onClick={()=>setShowEmailModal(false)}><X/></button></div>
                        <div className="p-8 space-y-4 overflow-y-auto">
                            <input type="email" value={emailTo} onChange={(e)=>setEmailTo(e.target.value)} placeholder="EmpfÃ¤nger" className="w-full rounded-xl py-3 px-4 border border-gray-200"/>
                            <input type="text" value={emailSubject} onChange={(e)=>setEmailSubject(e.target.value)} placeholder="Betreff" className="w-full rounded-xl py-3 px-4 border border-gray-200"/>
                            <textarea value={emailBody} onChange={(e)=>setEmailBody(e.target.value)} rows={8} className="w-full rounded-xl py-3 px-4 font-mono text-sm border border-gray-200"/>
                        </div>
                        <div className="p-6 border-t flex justify-end gap-3">
                            <button onClick={()=>setShowEmailModal(false)} className="px-4">Abbrechen</button>
                            <button onClick={handleSendEmail} disabled={isSendingEmail} className="btn-primary px-6 py-2 rounded-full font-bold text-xs flex gap-2">{isSendingEmail?<Loader2 className="animate-spin"/>:(emailSentSuccess?<CheckCircle2/>:<Send/>)} {emailSentSuccess?"Gesendet":"Senden"}</button>
                        </div>
                    </div>
                </div>
            )}
          </div>
        );
      };


      // ==========================================
      // 6. APP MAIN
      // ==========================================

      const App: React.FC = () => {
        const [script, setScript] = useState(() => localStorage.getItem('podcastScript') || '');
        const [topic, setTopic] = useState(() => localStorage.getItem('podcastTopic') || '');
        const [hostName, setHostName] = useState(() => localStorage.getItem('hostName') || 'Host');
        const [guestName, setGuestName] = useState(() => localStorage.getItem('guestName') || 'Guest');
        const [rssArticles, setRssArticles] = useState<RssArticle[]>(() => JSON.parse(localStorage.getItem('rssArticles') || '[]'));
        const [searchSources, setSearchSources] = useState<{ title: string; uri: string }[]>(() => JSON.parse(localStorage.getItem('searchSources') || '[]'));

        useEffect(() => { localStorage.setItem('hostName', hostName); }, [hostName]);
        useEffect(() => { localStorage.setItem('guestName', guestName); }, [guestName]);
        useEffect(() => { localStorage.setItem('podcastTopic', topic); }, [topic]);
        useEffect(() => { localStorage.setItem('podcastScript', script); }, [script]);
        useEffect(() => { localStorage.setItem('rssArticles', JSON.stringify(rssArticles)); }, [rssArticles]);
        useEffect(() => { localStorage.setItem('searchSources', JSON.stringify(searchSources)); }, [searchSources]);

        const handleScriptReady = (newScript: string) => {
          setScript(newScript);
        };

        return (
          <div className="container mx-auto max-w-[1200px] bg-white rounded-[16px] min-h-[calc(100vh-48px)] overflow-hidden shadow-sm border border-[rgba(0,0,0,0.05)]">
            <div className="relative bg-white px-10 py-16 text-center border-b-2 border-[#c0ae66] rounded-t-[16px] overflow-hidden">
              <div className="absolute inset-0 z-0 opacity-30" style={{backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 200"><path d="M0,50 Q300,100 600,50 T1200,50 L1200,0 L0,0 Z" fill="rgba(240,240,240,1)"/></svg>')`, backgroundRepeat: 'no-repeat', backgroundSize: 'cover'}} />
              <div className="relative z-10 flex flex-col items-center justify-center">
                <img src="https://anyever.de/wp-content/themes/anyever/static/images/logo-anyever-gold.svg" alt="Any Ever Logo" className="w-[200px] h-auto mb-2 opacity-95" />
                <div className="text-sm font-medium tracking-[0.05em] text-[#181818] uppercase mt-1">ENJOY.AUDIO</div>
                <h1 className="text-[2.5rem] font-[100] tracking-[4px] text-[#181818] mb-4">Podcast Generator</h1>
                <p className="text-[#717684] text-[1.1rem]">Was nur dich bewegt, an einem Ort.</p>
              </div>
            </div>
            <div className="grid grid-cols-1 gap-8 p-8 lg:p-12 bg-[#f9f9f9]">
              <div className="flex flex-col gap-8">
                <ScriptSection onScriptReady={handleScriptReady} hostName={hostName} setHostName={setHostName} guestName={guestName} setGuestName={setGuestName} topic={topic} setTopic={setTopic} setRssArticles={setRssArticles} setSearchSources={setSearchSources} />
                <AudioSection script={script} hostName={hostName} guestName={guestName} topic={topic} rssArticles={rssArticles} searchSources={searchSources} />
              </div>
            </div>
            <div className="text-center py-8 text-[#717684] text-xs bg-white border-t border-[rgba(0,0,0,0.05)]">Powered by Gemini 2.5 Flash & Flash-TTS â€¢ ANY EVER Audio Engine</div>
          </div>
        );
      };

      // ==========================================
      // 7. RENDER ROOT
      // ==========================================

      const rootElement = document.getElementById('root');
      if (rootElement) {
        const root = ReactDOM.createRoot(rootElement);
        root.render(<React.StrictMode><App /></React.StrictMode>);
      } else {
        console.error("Root element not found");
      }
    </script>
  </body>
</html>