<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ANY EVER | Podcast Generator (Browser Edition)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --any-ever-gold: #c0ae66;
        --any-ever-black: #181818;
        --any-ever-bright-grey: #f9f9f9;
      }
      body { font-family: 'Inter', sans-serif; background-color: var(--any-ever-bright-grey); color: var(--any-ever-black); padding: 24px; margin: 0; }
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
      .btn-primary { background: linear-gradient(135deg, #d4c585 0%, #c0ae66 100%); color: white; box-shadow: 0 8px 18px rgba(192,174,102,0.24); transition: all 0.2s ease; }
      .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(192,174,102,0.3); }
      .btn-primary:disabled { background: #e5e5e5; cursor: not-allowed; transform: none; box-shadow: none; }
      .card { background: white; border: 1px solid rgba(0,0,0,0.05); border-radius: 16px; box-shadow: 0 4px 18px rgba(0,0,0,0.04); }
      input:focus, textarea:focus, select:focus { border-color: var(--any-ever-gold) !important; outline: none; box-shadow: 0 0 0 3px rgba(192,174,102,0.1); }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0",
        "@google/genai": "https://esm.sh/@google/genai@0.1.1"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="react,typescript">
        import React, { useState, useEffect, useRef } from 'react';
        import ReactDOM from 'react-dom/client';
        import { Mic, Play, Pause, Download, Loader2, Volume2, Music, Upload, Square, Trash2, Disc, Mail, X, Send, FileAudio, CheckCircle2, Save, Sparkles, Globe, Users, Settings, ChevronDown, ChevronUp, RotateCcw, Rss, Plus, ExternalLink } from 'lucide-react';
        import { GoogleGenAI } from '@google/genai';

        // --- TYPES (Integrated from types.ts) ---
        // We change enum to const object for easier JS handling in Babel standalone
        const VoiceName = {
          Puck: 'Puck',
          Charon: 'Charon',
          Kore: 'Kore',
          Fenrir: 'Fenrir',
          Zephyr: 'Zephyr',
        };

        // --- UTILS: RSS (Integrated from rssUtils.ts) ---
        const fetchFeedContent = async (url) => {
            const cleanUrl = url.trim();
            const encodedUrl = encodeURIComponent(cleanUrl);
            try {
                const response = await fetch(`https://api.allorigins.win/get?url=${encodedUrl}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.contents) return data.contents;
                }
            } catch (e) { console.warn("AllOrigins failed", e); }
            try {
                const response = await fetch(`https://corsproxy.io/?${encodedUrl}`);
                if (response.ok) return await response.text();
            } catch (e) { console.warn("CorsProxy failed", e); }
            return null;
        };

        const fetchRssFeeds = async (urls) => {
            if (urls.length === 0) return { combinedContent: "", articles: [] };
            let combinedContent = "RSS FEED QUELLEMATERIAL (STRICT USE ONLY):\n";
            const allArticles = [];
            
            for (const url of urls.filter(u => u.trim().length > 0)) {
                try {
                    const xmlString = await fetchFeedContent(url);
                    if (!xmlString) continue;
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
                    if (xmlDoc.querySelector("parsererror")) continue;

                    let channelTitle = xmlDoc.querySelector("channel > title")?.textContent || "Unbekannte Quelle";
                    const items = Array.from(xmlDoc.querySelectorAll("item, entry")).slice(0, 5);
                    
                    combinedContent += `\n=== QUELLE: ${channelTitle} ===\n`;

                    items.forEach(item => {
                        const title = item.querySelector("title")?.textContent?.trim() || "Ohne Titel";
                        let fullText = item.getElementsByTagName("content:encoded")[0]?.textContent || item.querySelector("description")?.textContent || "";
                        fullText = fullText.replace(/<[^>]*>?/gm, ' ').replace(/\s+/g, ' ').trim();
                        
                        let link = item.querySelector("link")?.textContent?.trim() || "";
                        // Simple fallback link extraction
                        if (!link || !link.startsWith('http')) {
                           const guid = item.querySelector("guid")?.textContent?.trim();
                           if (guid && guid.startsWith('http')) link = guid;
                        }

                        allArticles.push({ title, description: fullText.substring(0,300), link, source: channelTitle });
                        combinedContent += `\n- ARTIKEL: "${title}"\n  QUELLE: ${channelTitle}\n  INHALT: ${fullText.substring(0, 2500)}\n`;
                    });
                } catch (e) { console.error("RSS Error", e); }
            }
            return { combinedContent, articles: allArticles };
        };

        // --- UTILS: AUDIO (Integrated from audioUtils.ts) ---
        const decodeBase64Audio = async (base64String, ctx) => {
            const binaryString = atob(base64String);
            const len = binaryString.length;
            // Fix odd length
            const bufferLen = len % 2 === 0 ? len : len - 1;
            const bytes = new Uint8Array(bufferLen);
            for (let i = 0; i < bufferLen; i++) bytes[i] = binaryString.charCodeAt(i);
            
            const dataInt16 = new Int16Array(bytes.buffer);
            const buffer = ctx.createBuffer(1, dataInt16.length, 24000);
            const channelData = buffer.getChannelData(0);
            for (let i = 0; i < dataInt16.length; i++) channelData[i] = dataInt16[i] / 32768.0;
            return buffer;
        };

        const decodeAudioBlob = async (blob, ctx) => {
            const arrayBuffer = await blob.arrayBuffer();
            return await ctx.decodeAudioData(arrayBuffer);
        };

        const audioBufferToMp3 = (buffer) => {
            if (!window.lamejs) throw new Error("LameJS not found");
            const channels = buffer.numberOfChannels;
            const mp3encoder = new window.lamejs.Mp3Encoder(channels, buffer.sampleRate, 192); // Reduced to 192kbps for better compatibility
            const mp3Data = [];
            const rawLeft = buffer.getChannelData(0);
            const rawRight = channels > 1 ? buffer.getChannelData(1) : rawLeft;
            const sampleBlockSize = 1152;
            const leftInt16 = new Int16Array(sampleBlockSize);
            const rightInt16 = new Int16Array(sampleBlockSize);

            for (let i = 0; i < rawLeft.length; i += sampleBlockSize) {
                const chunkLen = Math.min(sampleBlockSize, rawLeft.length - i);
                for (let j = 0; j < chunkLen; j++) {
                    const l = Math.max(-1, Math.min(1, rawLeft[i + j]));
                    const r = Math.max(-1, Math.min(1, rawRight[i + j]));
                    leftInt16[j] = (l < 0 ? l * 32768 : l * 32767);
                    rightInt16[j] = (r < 0 ? r * 32768 : r * 32767);
                }
                const lC = (chunkLen === sampleBlockSize) ? leftInt16 : leftInt16.subarray(0, chunkLen);
                const rC = (chunkLen === sampleBlockSize) ? rightInt16 : rightInt16.subarray(0, chunkLen);
                const mp3buf = (channels === 1) ? mp3encoder.encodeBuffer(lC) : mp3encoder.encodeBuffer(lC, rC);
                if (mp3buf.length > 0) mp3Data.push(mp3buf);
            }
            const mp3buf = mp3encoder.flush();
            if (mp3buf.length > 0) mp3Data.push(mp3buf);
            return new Blob(mp3Data, { type: 'audio/mp3' });
        };

        const mixPodcastSequence = async (voiceBuf, bgBuf, introBuf, outroBuf, mVol, iVol, oVol) => {
            const outRate = 44100;
            const iDur = introBuf ? introBuf.duration : 0;
            const vDur = voiceBuf.duration;
            const oDur = outroBuf ? outroBuf.duration : 0;
            const length = Math.ceil((iDur + vDur + oDur + 0.1) * outRate);
            const offlineCtx = new OfflineAudioContext(2, length, outRate);

            const add = (buf, vol, start, loop=false, stop) => {
                if(!buf) return;
                const src = offlineCtx.createBufferSource();
                src.buffer = buf;
                src.loop = loop;
                const gain = offlineCtx.createGain();
                gain.gain.value = vol;
                src.connect(gain);
                gain.connect(offlineCtx.destination);
                src.start(start);
                if(stop) src.stop(stop);
            };

            add(introBuf, iVol, 0);
            add(voiceBuf, 1.0, iDur);
            add(bgBuf, mVol, iDur, true, iDur + vDur);
            add(outroBuf, oVol, iDur + vDur);

            return await offlineCtx.startRendering();
        };

        const blobToBase64 = (blob) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        };

        // --- DB (Simplified) ---
        const openDB = () => {
             return new Promise((resolve, reject) => {
                const req = indexedDB.open('GeminiPodcastDB', 1);
                req.onupgradeneeded = (e) => e.target.result.createObjectStore('files');
                req.onsuccess = () => resolve(req.result);
                req.onerror = reject;
             });
        };
        const storeFile = async (key, file) => {
            const db = await openDB();
            const tx = db.transaction('files', 'readwrite');
            tx.objectStore('files').put({ key, name: file.name, blob: file }, key);
        };
        const getFile = async (key) => {
            const db = await openDB();
            return new Promise(resolve => {
                const req = db.transaction('files', 'readonly').objectStore('files').get(key);
                req.onsuccess = () => resolve(req.result ? { name: req.result.name, blob: req.result.blob } : null);
                req.onerror = () => resolve(null);
            });
        };
        const delFile = async (key) => {
             const db = await openDB();
             const tx = db.transaction('files', 'readwrite');
             tx.objectStore('files').delete(key);
        };

        // --- SERVICE: GEMINI (Modified for dynamic API Key) ---
        const getApiKey = () => localStorage.getItem('GEMINI_API_KEY') || '';

        const generateScript = async (topic, host, guest, useSearch, rssContent, sysInstr) => {
            const apiKey = getApiKey();
            if(!apiKey) throw new Error("Bitte API Key eingeben");
            const ai = new GoogleGenAI({ apiKey });
            const model = useSearch ? "gemini-2.0-flash" : "gemini-2.0-flash"; // Use 2.0 or 1.5 depending on access
            
            let prompt = `Thema: ${topic}\nSprecher: ${host} & ${guest}\n${rssContent ? "Nutze folgende RSS Quellen:\n" + rssContent : ""}\nGeneriere einen deutschen Dialog.`;
            
            const config = { systemInstruction: sysInstr, temperature: 0.3 };
            if(useSearch) config.tools = [{ googleSearch: {} }];

            const resp = await ai.models.generateContent({ model, contents: prompt, config });
            
            const text = resp.text || "";
            let sources = [];
            resp.candidates?.[0]?.groundingMetadata?.groundingChunks?.forEach(c => {
                if(c.web) sources.push({ title: c.web.title, uri: c.web.uri });
            });
            
            return { title: `Podcast: ${topic}`, script: text, searchSources: sources };
        };

        const generateVoicePreview = async (voice, text) => {
            const apiKey = getApiKey();
            const ai = new GoogleGenAI({ apiKey });
            const resp = await ai.models.generateContent({
                model: "gemini-2.0-flash-lite-preview-02-05", // Updated model name
                contents: [{ parts: [{ text }] }],
                config: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voice } } } }
            });
            return resp.candidates[0].content.parts[0].inlineData.data;
        };

        const generatePodcastAudio = async (script, hName, gName, hVoice, gVoice) => {
             const apiKey = getApiKey();
             const ai = new GoogleGenAI({ apiKey });
             const cleanScript = script.replace(/\*\*/g, '');
             const resp = await ai.models.generateContent({
                model: "gemini-2.0-flash-lite-preview-02-05",
                contents: [{ parts: [{ text: cleanScript }] }],
                config: { 
                    responseModalities: ["AUDIO"], 
                    speechConfig: { multiSpeakerVoiceConfig: { speakerVoiceConfigs: [
                        { speaker: hName, voiceConfig: { prebuiltVoiceConfig: { voiceName: hVoice } } },
                        { speaker: gName, voiceConfig: { prebuiltVoiceConfig: { voiceName: gVoice } } }
                    ]}}
                }
             });
             return resp.candidates[0].content.parts[0].inlineData.data;
        };

        // --- COMPONENTS ---

        // 1. API Key Modal
        const ApiKeyModal = ({ onClose }) => {
            const [key, setKey] = useState(getApiKey());
            const save = () => {
                localStorage.setItem('GEMINI_API_KEY', key);
                onClose();
            };
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                    <div className="bg-white p-6 rounded-xl shadow-xl max-w-md w-full">
                        <h3 className="text-lg font-bold mb-4">Google Gemini API Key</h3>
                        <p className="text-sm text-gray-600 mb-4">Da diese App im Browser l√§uft, wird der Key lokal in deinem Browser gespeichert.</p>
                        <input type="password" value={key} onChange={e=>setKey(e.target.value)} className="w-full border p-2 rounded mb-4" placeholder="AIza..." />
                        <button onClick={save} className="btn-primary w-full py-2 rounded-lg">Speichern</button>
                        <div className="mt-4 text-xs text-gray-400 text-center">
                           Kein Key? <a href="https://aistudio.google.com/" target="_blank" className="underline">Hier kostenlos erstellen</a>
                        </div>
                    </div>
                </div>
            );
        };

        // 2. Script Section (Simplified)
        const ScriptSection = ({ onScriptReady, hostName, setHostName, guestName, setGuestName, topic, setTopic, setRssArticles, setSearchSources }) => {
            const [loading, setLoading] = useState(false);
            const [script, setScript] = useState("");
            const [useSearch, setUseSearch] = useState(false);
            const [useRss, setUseRss] = useState(false);
            const [rssFeeds, setRssFeeds] = useState([]);
            const [newRss, setNewRss] = useState("");
            const [sysInstr, setSysInstr] = useState("Du bist ein Podcast Produzent. Schreibe einen spannenden Dialog auf Deutsch.");

            const handleGen = async () => {
                setLoading(true);
                try {
                    let rssText = "";
                    if(useRss && rssFeeds.length) {
                        const res = await fetchRssFeeds(rssFeeds);
                        rssText = res.combinedContent;
                        setRssArticles(res.articles);
                    }
                    const res = await generateScript(topic, hostName, guestName, useSearch, rssText, sysInstr);
                    setScript(res.script);
                    setSearchSources(res.searchSources || []);
                    onScriptReady(res.script);
                } catch(e) { alert(e.message); }
                setLoading(false);
            };

            return (
                <div className="card p-8">
                    <h2 className="text-xl font-medium mb-6 flex gap-2 items-center"><Sparkles className="text-[#c0ae66]"/> SKRIPT GENERIEREN</h2>
                    <div className="grid grid-cols-2 gap-4 mb-4">
                        <input value={hostName} onChange={e=>setHostName(e.target.value)} className="border p-3 rounded-xl" placeholder="Host Name" />
                        <input value={guestName} onChange={e=>setGuestName(e.target.value)} className="border p-3 rounded-xl" placeholder="Gast Name" />
                    </div>
                    <input value={topic} onChange={e=>setTopic(e.target.value)} className="border p-3 rounded-xl w-full mb-4" placeholder="Thema..." />
                    
                    <div className="flex gap-4 mb-6">
                        <label className="flex gap-2 items-center cursor-pointer"><input type="checkbox" checked={useSearch} onChange={e=>setUseSearch(e.target.checked)} /> Google Search</label>
                        <label className="flex gap-2 items-center cursor-pointer"><input type="checkbox" checked={useRss} onChange={e=>setUseRss(e.target.checked)} /> RSS Feeds</label>
                    </div>

                    {useRss && (
                        <div className="mb-4 p-4 bg-gray-50 rounded-xl">
                            <div className="flex gap-2 mb-2">
                                <input value={newRss} onChange={e=>setNewRss(e.target.value)} placeholder="RSS URL" className="flex-1 p-2 rounded border" />
                                <button onClick={()=>{if(newRss) setRssFeeds([...rssFeeds, newRss]); setNewRss("")}} className="bg-gray-200 px-4 rounded">+</button>
                            </div>
                            {rssFeeds.map((r,i) => <div key={i} className="text-xs truncate">{r}</div>)}
                        </div>
                    )}

                    <button onClick={handleGen} disabled={loading} className="btn-primary w-full py-4 rounded-full font-bold flex justify-center gap-2">
                        {loading ? <Loader2 className="animate-spin"/> : <Sparkles/>} SKRIPT ERSTELLEN
                    </button>

                    {script && <textarea value={script} onChange={e=>{setScript(e.target.value); onScriptReady(e.target.value)}} className="w-full h-64 mt-6 p-4 border rounded-xl" />}
                </div>
            );
        };

        // 3. Audio Section
        const AudioSection = ({ script, hostName, guestName }) => {
            const [loading, setLoading] = useState(false);
            const [audioUrl, setAudioUrl] = useState(null);
            const [hostVoice, setHostVoice] = useState(VoiceName.Kore);
            const [guestVoice, setGuestVoice] = useState(VoiceName.Puck);
            const [introFile, setIntroFile] = useState(null);
            const [outroFile, setOutroFile] = useState(null);
            const [musicFile, setMusicFile] = useState(null);
            const [vol, setVol] = useState({ music: 0.1, intro: 0.5, outro: 0.5 });

            const handleFile = async (e, type) => {
                if(e.target.files[0]) {
                    const f = e.target.files[0];
                    await storeFile(type, f);
                    const obj = { name: f.name, blob: f };
                    if(type==='intro') setIntroFile(obj);
                    if(type==='outro') setOutroFile(obj);
                    if(type==='music') setMusicFile(obj);
                }
            };

            const generate = async () => {
                setLoading(true);
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // 1. TTS
                    const ttsBase64 = await generatePodcastAudio(script, hostName, guestName, hostVoice, guestVoice);
                    const voiceBuf = await decodeBase64Audio(ttsBase64, ctx);

                    // 2. Load User Files
                    let iBuf = introFile ? await decodeAudioBlob(introFile.blob, ctx) : null;
                    let oBuf = outroFile ? await decodeAudioBlob(outroFile.blob, ctx) : null;
                    let mBuf = musicFile ? await decodeAudioBlob(musicFile.blob, ctx) : null;

                    // 3. Mix
                    const finalBuf = await mixPodcastSequence(voiceBuf, mBuf, iBuf, oBuf, vol.music, vol.intro, vol.outro);
                    
                    // 4. Encode
                    const mp3Blob = audioBufferToMp3(finalBuf);
                    setAudioUrl(URL.createObjectURL(mp3Blob));
                } catch(e) { console.error(e); alert("Fehler: " + e.message); }
                setLoading(false);
            };

            return (
                <div className={`card p-8 mt-8 transition-opacity ${!script ? 'opacity-50 pointer-events-none' : 'opacity-100'}`}>
                     <h2 className="text-xl font-medium mb-6 flex gap-2 items-center"><Volume2 className="text-[#c0ae66]"/> AUDIO PRODUZIEREN</h2>
                     
                     <div className="grid grid-cols-2 gap-6 mb-6">
                        <div>
                            <label className="text-xs font-bold text-gray-500">STIMME {hostName}</label>
                            <select value={hostVoice} onChange={e=>setHostVoice(e.target.value)} className="w-full p-2 border rounded-lg bg-gray-50">
                                {Object.values(VoiceName).map(v => <option key={v}>{v}</option>)}
                            </select>
                        </div>
                        <div>
                            <label className="text-xs font-bold text-gray-500">STIMME {guestName}</label>
                            <select value={guestVoice} onChange={e=>setGuestVoice(e.target.value)} className="w-full p-2 border rounded-lg bg-gray-50">
                                {Object.values(VoiceName).map(v => <option key={v}>{v}</option>)}
                            </select>
                        </div>
                     </div>

                     <div className="grid grid-cols-3 gap-4 mb-8">
                        {['intro', 'music', 'outro'].map(type => (
                            <div key={type} className="border p-4 rounded-xl text-center bg-gray-50 hover:border-[#c0ae66]">
                                <div className="text-xs uppercase font-bold mb-2">{type}</div>
                                <input type="file" accept="audio/*" className="text-xs w-full" onChange={(e)=>handleFile(e, type)} />
                            </div>
                        ))}
                     </div>

                     <button onClick={generate} disabled={loading} className="btn-primary w-full py-4 rounded-full font-bold flex justify-center gap-2">
                        {loading ? <Loader2 className="animate-spin"/> : <Music/>} MIXDOWN STARTEN
                    </button>

                    {audioUrl && (
                        <div className="mt-6 p-6 bg-gray-50 border border-[#c0ae66] rounded-xl">
                            <div className="flex justify-between items-center mb-4">
                                <div className="font-bold">Fertiger Podcast</div>
                                <a href={audioUrl} download="podcast.mp3" className="bg-black text-white px-4 py-2 rounded-full text-sm flex gap-2"><Download size={16}/> Download</a>
                            </div>
                            <audio src={audioUrl} controls className="w-full accent-[#c0ae66]" />
                        </div>
                    )}
                </div>
            );
        };

        // --- MAIN APP ---
        const App = () => {
            const [showKeyModal, setShowKeyModal] = useState(!getApiKey());
            const [script, setScript] = useState("");
            const [hostName, setHostName] = useState("Sarah");
            const [guestName, setGuestName] = useState("Tom");
            const [topic, setTopic] = useState("");
            const [rssArticles, setRssArticles] = useState([]);
            const [searchSources, setSearchSources] = useState([]);

            return (
                <div className="container mx-auto max-w-[1000px]">
                    {showKeyModal && <ApiKeyModal onClose={()=>setShowKeyModal(false)} />}
                    
                    {/* HEADER */}
                    <div className="text-center py-12 bg-white rounded-t-2xl border-b-2 border-[#c0ae66] relative overflow-hidden">
                         <h1 className="text-4xl font-thin tracking-widest mb-2">ANY EVER</h1>
                         <div className="text-sm text-gray-500 tracking-widest uppercase">Podcast Generator</div>
                    </div>

                    {/* CONTENT */}
                    <div className="bg-[#f9f9f9] p-8">
                        <ScriptSection 
                            onScriptReady={setScript}
                            hostName={hostName} setHostName={setHostName}
                            guestName={guestName} setGuestName={setGuestName}
                            topic={topic} setTopic={setTopic}
                            setRssArticles={setRssArticles} setSearchSources={setSearchSources}
                        />
                        <AudioSection script={script} hostName={hostName} guestName={guestName} />
                    </div>
                    
                    <div className="bg-white p-4 text-center text-xs text-gray-400 rounded-b-2xl">
                        Powered by Gemini 2.0 Flash & Browser Audio Engine
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
